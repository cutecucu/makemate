<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테셀레이션 도안 만들기 (Escher Style)</title>
    <!-- Tailwind CSS 로드 --><script src="https://cdn.tailwindcss.com"></script>
    <!-- p5.js 라이브러리 로드 --><script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        /* 기본 폰트 및 배경 설정 */
        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            overflow: hidden; /* 스크롤 방지 */
            margin: 0; /* body의 기본 마진 제거 */
            background-color: #f1f5f9; /* bg-gray-100 */
        }
        
        /* 인쇄 시 스타일 */
        @media print {
            /* 인쇄 시 UI 요소(헤더, 컨트롤 패널) 숨기기 */
            body > div:not(#canvas-container) {
                display: none !important;
            }
            
            /* 캔버스가 인쇄 페이지를 꽉 채우도록 */
            #canvas-container {
                position: fixed !important; 
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                z-index: 9999 !important;
            }

            #canvas-container canvas {
                width: 100% !important;
                height: 100% !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- [신규] 상단 헤더 (제목/로고) -->
    <div class="absolute top-0 left-0 z-20 w-full bg-white/80 backdrop-blur-sm shadow-md pt-8 pb-4 pl-8 pr-8 flex justify-between items-center">
        <div>
            <h1 class="text-3xl font-bold text-gray-800">테셀레이션 도안 만들기</h1>
            <p class="text-gray-600 mt-2">사각형에서 조각을 잘라 평행이동시킵니다.</p>
        </div>
        <div class="w-16 h-16 bg-indigo-600 rounded-full flex items-center justify-center text-white text-2xl font-bold shadow-md flex-shrink-0">
            T
        </div>
    </div>

    <!-- [수정] 좌측 컨트롤 패널 (제목/로고 제거, 상단 패딩 추가) -->
    <div id="controls-panel" class="absolute top-0 left-0 z-10 w-full max-w-sm h-screen bg-white/80 backdrop-blur-sm shadow-lg p-8 pt-36 overflow-y-auto"> 
        <!-- pt-36 : 상단 헤더(약 9rem)를 위한 공간 확보 -->
        
        <!-- [수정] 사용 방법 (화살표 제거) -->
        <h2 class="text-xl font-semibold text-gray-700 mb-4">사용 방법</h2>
        <div class="space-y-4">
            <button id="draw-left" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center justify-center">
                <span>1. 왼쪽 조각 자르기</span>
            </button>
            <!-- [삭제] 화살표 제거 -->
            <!-- <div class="text-center text-gray-400 text-2xl">&darr;</div> -->
            <button id="draw-top" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center justify-center">
                <span>2. 위쪽 조각 자르기</span>
            </button>
            <!-- [삭제] 화살표 제거 -->
            <!-- <div class="text-center text-gray-400 text-2xl">&darr;</div> -->
            <button id="print" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center justify-center">
                <span>3. 인쇄하기</span>
            </button>
            
            <!-- [유지] 구분선 -->
            <span class="block border-t border-gray-300 my-6"></span>
            <button id="reset" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition duration-200">
                초기화
            </button>
        </div>
    </div>
    
    <!-- 캔버스 컨테이너 (전체 화면) -->
    <div id="canvas-container" class="absolute top-0 left-0 w-screen h-screen z-0">
        <!-- p5.js 캔버스가 여기에 삽입됩니다 -->
    </div>

    <script>
        // === 전역 변수 설정 ===
        let tileSize = 200;   
        let tileX, tileY;     
        
        let errorMsg = ''; // 캔버스에 표시할 에러 메시지
        let controlsWidth = 384; // 컨트롤 패널 너비 (max-w-sm)

        let leftCutPoints = [];  
        let topCutPoints = [];   

        let leftPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };
        let topPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };

        let drawingState = 'none'; 
        let isDrawing = false;
        let showTessellation = false; 

        let draggingPiece = null; 
        let dragOffsetX, dragOffsetY; 

        let colorA, colorB, guideColor; 

        // === p5.js 스케치 ===

        const sketch = (p) => {
            
            let controlsPanel; // 컨트롤 패널 DOM 요소

            p.setup = () => {
                const container = document.getElementById('canvas-container');
                let cnv = p.createCanvas(p.windowWidth, p.windowHeight); 
                cnv.parent('canvas-container');

                controlsPanel = document.getElementById('controls-panel');
                controlsWidth = controlsPanel.offsetWidth;

                // tileX/Y 계산: 좌측 패널을 제외한 영역의 중앙
                tileX = controlsWidth + ( (p.windowWidth - controlsWidth) / 2 ) - (tileSize / 2); 
                tileY = (p.windowHeight / 2) - (tileSize / 2); // 세로 중앙

                colorA = p.color(110, 168, 255, 200); // Blue
                colorB = p.color(255, 255, 255, 200); // White
                guideColor = p.color(255, 0, 0, 150); // Red (drawing guide)

                p.strokeWeight(3); // 기본 선 굵기
            };

            p.draw = () => {
                p.background(241, 245, 249); // bg-gray-100

                // === 좌표계 이동 ===
                p.translate(tileX, tileY);

                // 모눈종이 배경 그리기
                drawGrid(); 

                if (showTessellation) {
                    drawTessellation();
                } else {
                    if (leftCutPoints.length > 2 || topCutPoints.length > 2) {
                        drawTessellationOutline();
                    }
                    drawConstruction();
                }
                
                // 캔버스에 텍스트 그리기
                drawStatusText();

                p.noLoop(); 
            };
            
            // --- 그리기 함수들 ---
            
            /** 타일 모양을 그리는 핵심 함수 */
            function drawTileShape(ox, oy, fillColor) {
                p.fill(fillColor);
                p.stroke(30); 
                p.strokeWeight(2.5); // 타일 선 굵기

                p.beginShape();
                // 1. 위쪽 변
                if (topCutPoints.length === 0 || !topPiece.snapped) {
                    p.vertex(ox, oy); p.vertex(ox + tileSize, oy);
                } else {
                    for (let pt of topCutPoints) { p.vertex(ox + pt.x, oy + pt.y); }
                }
                // 2. 오른쪽 변
                if (leftCutPoints.length === 0 || !leftPiece.snapped) {
                    p.vertex(ox + tileSize, oy + tileSize);
                } else {
                    for (let pt of leftCutPoints) { p.vertex(ox + tileSize + pt.x, oy + pt.y); }
                }
                // 3. 아래쪽 변
                if (topCutPoints.length === 0 || !topPiece.snapped) {
                    p.vertex(ox, oy + tileSize);
                } else {
                    for (let i = topCutPoints.length - 1; i >= 0; i--) {
                        p.vertex(ox + topCutPoints[i].x, oy + tileSize + topCutPoints[i].y);
                    }
                }
                // 4. 왼쪽 변
                if (leftCutPoints.length === 0 || !leftPiece.snapped) {
                    p.vertex(ox, oy);
                } else {
                    for (let i = leftCutPoints.length - 1; i >= 0; i--) {
                        p.vertex(ox + leftCutPoints[i].x, oy + leftCutPoints[i].y);
                    }
                }
                p.endShape(p.CLOSE);
                p.noFill();
            }

            /** 그리기 및 조각 이동 과정을 보여주는 함수 */
            function drawConstruction() {
                p.strokeWeight(2); // 기본 사각형 굵기
                p.stroke(200); 
                p.noFill();
                p.rect(0, 0, tileSize, tileSize); 

                // 실제 타일 채우기
                p.fill(colorA); 
                p.stroke(p.color(50,50,50,150)); 
                p.strokeWeight(3); // 작업 타일 굵기
                p.beginShape();
                p.vertex(0, 0);
                // 상단 변
                if (topCutPoints.length > 0 && topPiece.snapped) {
                    for (let pt of topCutPoints) { p.vertex(pt.x, pt.y); }
                } else { p.vertex(tileSize, 0); }
                // 우측 변
                if (leftCutPoints.length > 0 && leftPiece.snapped) {
                     for (let pt of leftCutPoints) { p.vertex(tileSize + pt.x, pt.y); }
                } else { p.vertex(tileSize, tileSize); }
                // 하단 변
                if (topCutPoints.length > 0 && topPiece.snapped) {
                    for (let i = topCutPoints.length - 1; i >= 0; i--) {
                        p.vertex(topCutPoints[i].x, tileSize + topCutPoints[i].y);
                    }
                } else { p.vertex(0, tileSize); }
                // 좌측 변
                if (leftCutPoints.length > 0 && leftPiece.snapped) {
                    for (let i = leftCutPoints.length - 1; i >= 0; i--) {
                        p.vertex(leftCutPoints[i].x, leftCutPoints[i].y);
                    }
                } else { p.vertex(0, 0); }
                p.endShape(p.CLOSE);

                // --- 조각 그리기 (leftPiece) ---
                if (leftCutPoints.length > 0) {
                    p.push();
                    p.translate(leftPiece.x, leftPiece.y); 
                    if (draggingPiece === leftPiece) {
                        p.fill(p.color(59, 130, 246, 150)); 
                        p.stroke(p.color(59, 130, 246)); p.strokeWeight(4); 
                    } else if (!leftPiece.snapped) {
                        p.fill(p.color(59, 130, 246, 200)); 
                        p.stroke(p.color(59, 130, 246)); p.strokeWeight(3); 
                    }
                    if (!leftPiece.snapped || draggingPiece === leftPiece) {
                         drawPieceShape(leftCutPoints);
                    }
                    p.pop();
                    // 스냅 가이드
                    if (drawingState === 'none' && !leftPiece.snapped && draggingPiece !== leftPiece) {
                        const snapX = tileSize; 
                        p.stroke(p.color(59, 130, 246, 100)); 
                        p.drawingContext.setLineDash([5, 5]);
                        p.beginShape();
                        for (let pt of leftCutPoints) { p.vertex(snapX + pt.x, pt.y); }
                        p.endShape();
                        p.drawingContext.setLineDash([]);
                    }
                }

                // --- 조각 그리기 (topPiece) ---
                if (topCutPoints.length > 0) {
                    p.push();
                    p.translate(topPiece.x, topPiece.y); 
                    if (draggingPiece === topPiece) {
                        p.fill(p.color(34, 197, 94, 150)); 
                        p.stroke(p.color(34, 197, 94)); p.strokeWeight(4); 
                    } else if (!topPiece.snapped) {
                        p.fill(p.color(34, 197, 94, 200)); 
                        p.stroke(p.color(34, 197, 94)); p.strokeWeight(3); 
                    }
                     if (!topPiece.snapped || draggingPiece === topPiece) {
                        drawPieceShape(topCutPoints);
                    }
                    p.pop();
                     // 스냅 가이드
                    if (drawingState === 'none' && !topPiece.snapped && draggingPiece !== topPiece) {
                        const snapY = tileSize; 
                        p.stroke(p.color(34, 197, 94, 100)); 
                        p.drawingContext.setLineDash([5, 5]);
                        p.beginShape();
                        for (let pt of topCutPoints) { p.vertex(pt.x, snapY + pt.y); }
                        p.endShape();
                        p.drawingContext.setLineDash([]);
                    }
                }

                // 그리기 모드 안내선 (점선)
                p.strokeWeight(3); // 안내선 굵기
                p.stroke(guideColor);
                p.noFill();
                
                p.drawingContext.setLineDash([10, 5]); // 점선 스타일

                if (drawingState === 'left') { p.line(0, 0, 0, tileSize); } 
                else if (drawingState === 'top') { p.line(0, 0, tileSize, 0); }

                p.drawingContext.setLineDash([]); // 점선 스타일 해제
            }

            /** 주어진 점들로 다각형을 그리는 헬퍼 함수 */
            function drawPieceShape(points) {
                p.beginShape();
                for (let pt of points) { p.vertex(pt.x, pt.y); }
                p.endShape(p.CLOSE);
            }

            /** 모눈종이 배경 그리기 (점으로 변경) */
            function drawGrid() {
                let gridSpacing = 20; 
                p.fill(220); // 점 색상
                p.noStroke();
                
                const startX = -tileX; const startY = -tileY;
                const endX = p.width - tileX; const endY = p.height - tileY;
                let firstGridX = p.floor(startX / gridSpacing) * gridSpacing;
                let firstGridY = p.floor(startY / gridSpacing) * gridSpacing;

                for (let x = firstGridX; x < endX; x += gridSpacing) {
                    for (let y = firstGridY; y < endY; y += gridSpacing) {
                        p.circle(x, y, 2); // 2px 지름의 원 (점)
                    }
                }
            }


            /** 테셀레이션 윤곽선 실시간 그리기 */
            function drawTessellationOutline() {
                const startX = p.floor(-tileX / tileSize) * tileSize;
                const startY = p.floor(-tileY / tileSize) * tileSize;
                const endX = p.width - tileX; 
                const endY = p.height - tileY;

                for (let y = startY; y < endY; y += tileSize) {
                    for (let x = startX; x < endX; x += tileSize) {
                        drawTileOutline(x, y);
                    }
                }
            }

            /** 타일 윤곽선 하나 그리기 */
            function drawTileOutline(ox, oy) {
                p.noFill();
                p.stroke(100, 100, 200, 100); 
                p.strokeWeight(2); // 윤곽선 굵기
                
                p.beginShape();
                // 1. Top edge
                if (topCutPoints.length > 2) {
                    for (let pt of topCutPoints) { p.vertex(ox + pt.x, oy + pt.y); }
                } else { p.vertex(ox, oy); p.vertex(ox + tileSize, oy); }
                // 2. Right edge
                if (leftCutPoints.length > 2) {
                    for (let pt of leftCutPoints) { p.vertex(ox + tileSize + pt.x, oy + pt.y); }
                } else { p.vertex(ox + tileSize, oy + tileSize); }
                // 3. Bottom edge
                if (topCutPoints.length > 2) {
                    for (let i = topCutPoints.length - 1; i >= 0; i--) {
                        p.vertex(ox + topCutPoints[i].x, oy + tileSize + topCutPoints[i].y);
                    }
                } else { p.vertex(ox, oy + tileSize); }
                // 4. Left edge
                if (leftCutPoints.length > 2) {
                    for (let i = leftCutPoints.length - 1; i >= 0; i--) {
                        p.vertex(ox + leftCutPoints[i].x, oy + leftCutPoints[i].y);
                    }
                } else { p.vertex(ox, oy); }
                p.endShape(p.CLOSE);
            }

            /** 테셀레이션 모드일 때 타일 반복 그리기 */
            function drawTessellation() {
                const startX = p.floor(-tileX / tileSize) * tileSize;
                const startY = p.floor(-tileY / tileSize) * tileSize;
                const endX = p.width - tileX; 
                const endY = p.height - tileY;

                for (let y = startY; y < endY; y += tileSize) {
                    for (let x = startX; x < endX; x += tileSize) {
                        let color = ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) ? colorA : colorB;
                        drawTileShape(x, y, color);
                    }
                }
            }

            /** 상태 메시지를 캔버스에 직접 그리기 */
            function drawStatusText() {
                let msg = errorMsg; // 에러 메시지를 우선 표시

                if (msg === '') { // 에러가 없으면 일반 상태 메시지 확인
                    if (drawingState === 'left') { msg = '왼쪽 변을 잘라내고 있습니다...'; } 
                    else if (drawingState === 'top') { msg = '위쪽 변을 잘라내고 있습니다...'; } 
                    else if (draggingPiece === leftPiece) { msg = '파란색 조각을 오른쪽으로 드래그하여 붙이세요.'; } 
                    else if (draggingPiece === topPiece) { msg = '초록색 조각을 아래쪽으로 드래그하여 붙이세요.'; } 
                    else if (leftCutPoints.length > 0 && !leftPiece.snapped) { msg = '파란색 조각을 클릭하여 오른쪽으로 이동하세요.'; } 
                    else if (topCutPoints.length > 0 && !topPiece.snapped) { msg = '초록색 조각을 클릭하여 아래쪽으로 이동하세요.'; }
                }
                
                if (msg) {
                    p.push(); // p5.js의 그리기 상태 저장
                    p.fill(220, 0, 0); // (빨간색)
                    p.stroke(255);     // (흰색 테두리)
                    p.strokeWeight(3);
                    p.textStyle(p.BOLD);
                    p.textSize(24);
                    p.textAlign(p.CENTER, p.BOTTOM); // 텍스트 정렬
                    
                    // [수정] 텍스트 위치: 위로 더 올림 (-30 -> -60)
                    p.text(msg, tileSize / 2, -60); 
                    p.pop(); // p5.js의 그리기 상태 복원
                }

                // 에러 메시지는 한 번 그린 후 초기화
                if (errorMsg !== '') {
                    errorMsg = '';
                }
            }

            // === p5.js 마우스 이벤트 핸들러 ===

            p.mousePressed = () => {
                const mx = p.mouseX - tileX; 
                const my = p.mouseY - tileY; 

                if (drawingState !== 'none') {
                    isDrawing = true;
                    if (drawingState === 'left') {
                        leftCutPoints = [{ x: 0, y: 0 }]; 
                    } else if (drawingState === 'top') {
                        topCutPoints = [{ x: 0, y: 0 }]; 
                    }
                } else {
                    // 간단한 충돌 판정
                    let checkWidth = p.max(tileSize / 2, leftPiece.width);
                    let checkHeight = p.max(tileSize / 2, leftPiece.height);
                    if (leftCutPoints.length > 0 && !leftPiece.snapped && p.abs(mx - leftPiece.x) < checkWidth && p.abs(my - leftPiece.y) < checkHeight) { 
                        draggingPiece = leftPiece;
                        dragOffsetX = mx - leftPiece.x; dragOffsetY = my - leftPiece.y;
                    } else if (topCutPoints.length > 0 && !topPiece.snapped && p.abs(mx - topPiece.x) < checkWidth && p.abs(my - topPiece.y) < checkHeight) { 
                        draggingPiece = topPiece;
                        dragOffsetX = mx - topPiece.x; dragOffsetY = my - topPiece.y;
                    }
                }
                p.redraw();
            };

            p.mouseDragged = () => {
                const mx = p.mouseX - tileX;
                const my = p.mouseY - tileY;

                if (isDrawing) {
                    if (drawingState === 'left') {
                        let constrainedX = p.constrain(mx, -tileSize / 2, tileSize / 2); 
                        let constrainedY = p.constrain(my, 0, tileSize); 
                        leftCutPoints.push({ x: constrainedX, y: constrainedY });
                    } else if (drawingState === 'top') {
                        let constrainedX = p.constrain(mx, 0, tileSize); 
                        let constrainedY = p.constrain(my, -tileSize / 2, tileSize / 2); 
                        topCutPoints.push({ x: constrainedX, y: constrainedY });
                    }
                } else if (draggingPiece) {
                    if (draggingPiece === leftPiece) {
                        draggingPiece.x = mx - dragOffsetX;
                        draggingPiece.y = my - dragOffsetY;
                        draggingPiece.y = p.constrain(draggingPiece.y, 0, tileSize - leftPiece.height); 
                        draggingPiece.x = p.constrain(draggingPiece.x, -tileSize / 2, tileSize); 
                        if (p.abs(draggingPiece.x - tileSize) < 20) { 
                            draggingPiece.x = tileSize; draggingPiece.snapped = true;
                        } else { draggingPiece.snapped = false; }
                    } else if (draggingPiece === topPiece) {
                        draggingPiece.x = mx - dragOffsetX;
                        draggingPiece.y = my - dragOffsetY;
                        draggingPiece.x = p.constrain(draggingPiece.x, 0, tileSize - topPiece.width);
                        draggingPiece.y = p.constrain(draggingPiece.y, -tileSize / 2, tileSize); 
                        if (p.abs(draggingPiece.y - tileSize) < 20) { 
                            draggingPiece.y = tileSize; draggingPiece.snapped = true;
                        } else { draggingPiece.snapped = false; }
                    }
                }
                p.redraw();
            };

            p.mouseReleased = () => {
                if (isDrawing) {
                    if (drawingState === 'left') {
                        leftCutPoints.push({ x: 0, y: tileSize }); 
                        leftPiece.points = leftCutPoints;
                        leftPiece.x = 0; leftPiece.y = 0;
                        leftPiece.width = p.max(leftCutPoints.map(pt => pt.x)) - p.min(leftCutPoints.map(pt => pt.x));
                        leftPiece.height = tileSize;
                    } else if (drawingState === 'top') {
                        topCutPoints.push({ x: tileSize, y: 0 }); 
                        topPiece.points = topCutPoints;
                        topPiece.x = 0; topPiece.y = 0;
                        topPiece.width = tileSize;
                        topPiece.height = p.max(topCutPoints.map(pt => pt.y)) - p.min(topCutPoints.map(pt => pt.y));
                    }
                    drawingState = 'none';
                    isDrawing = false;
                } else if (draggingPiece) {
                    if (!draggingPiece.snapped) {
                        draggingPiece.x = 0; draggingPiece.y = 0; 
                    }
                    draggingPiece = null;
                }
                p.redraw();
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
    
                controlsWidth = controlsPanel.offsetWidth; // 패널 너비 다시 계산
                tileX = controlsWidth + ( (p.windowWidth - controlsWidth) / 2 ) - (tileSize / 2);
                tileY = (p.windowHeight / 2) - (tileSize / 2);
                p.redraw(); 
            };

        }; // End of sketch function

        let myp5 = new p5(sketch);

        // === HTML 버튼 이벤트 핸들러 ===
        document.getElementById('draw-left').addEventListener('click', () => {
            drawingState = 'left';
            showTessellation = false; 
            leftCutPoints = []; 
            leftPiece.snapped = false; leftPiece.x = 0; leftPiece.y = 0; 
            myp5.redraw();
        });

        document.getElementById('draw-top').addEventListener('click', () => {
            if (!leftPiece.snapped) {
                // 캔버스에 에러 메시지 설정
                errorMsg = '먼저 왼쪽 조각을 오른쪽으로 이동시켜야 합니다.';
                myp5.redraw();
                return;
            }
            drawingState = 'top';
            showTessellation = false; 
            topCutPoints = []; 
            topPiece.snapped = false; topPiece.x = 0; topPiece.y = 0; 
            myp5.redraw();
        });

        document.getElementById('print').addEventListener('click', () => {
            if (!leftPiece.snapped || !topPiece.snapped) {
                // 캔버스에 에러 메시지 설정
                errorMsg = '모든 조각을 이동시켜야 인쇄할 수 있습니다.';
                myp5.redraw();
                return;
            }
            drawingState = 'none';
            showTessellation = true; 
            myp5.redraw(); 
            
            setTimeout(window.print, 500); 
        });

        document.getElementById('reset').addEventListener('click', () => {
            errorMsg = ''; // 리셋 시 에러 메시지 초기화
            leftCutPoints = [];
            topCutPoints = [];
            leftPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };
            topPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };
            drawingState = 'none';
            isDrawing = false;
            showTessellation = false;
            draggingPiece = null;
            myp5.redraw(); 
        });

    </script>
</body>
</html>


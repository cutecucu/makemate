<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>테셀레이션 도안 만들기 (Escher Style)</title>
    
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- p5.js 로드 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        /* p5.js 캔버스가 생성될 컨테이너 */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* UI 뒤에 배치 */
        }
        
        /* 인쇄 시 UI 숨기기 */
        @media print {
            #controls-panel, .absolute.z-20 {
                display: none !important;
            }
            #canvas-container {
                z-index: 9999; /* 캔버스만 인쇄 */
            }
        }
    </style>
</head>
<body class="bg-gray-100 overflow-hidden"> <!-- 스크롤 방지 -->

    <!-- [수정] 상단 헤더: 모바일(기본)에서는 작게, md(768px) 이상에서는 크게 표시 -->
    <div class="absolute top-0 left-0 z-20 w-full bg-white/80 backdrop-blur-sm shadow-md pt-2 pb-2 px-4 md:pt-4 md:pb-4 md:px-6 flex justify-between items-center">
        <div>
            <h1 class="text-lg md:text-2xl font-bold text-gray-800">테셀레이션 도안 만들기</h1>
            <p class="text-xs md:text-sm text-gray-600 mt-1">사각형에서 조각을 잘라 평행이동시킵니다.</p>
        </div>
        <div class="w-8 h-8 md:w-12 md:h-12 bg-indigo-600 rounded-full flex items-center justify-center text-white text-base md:text-xl font-bold shadow-md flex-shrink-0">
            T
        </div>
    </div>

    <!-- [수정] 좌측 컨트롤 패널: 모바일(기본)에서는 패딩을 줄이고, md 이상에서는 크게 -->
    <div id="controls-panel" class="absolute top-0 left-0 z-10 w-full max-w-sm h-screen bg-white/80 backdrop-blur-sm shadow-lg p-4 pt-16 md:p-8 md:pt-28 overflow-y-auto"> 
        <!-- pt-16(모바일) / md:pt-28(데스크톱) : 상단 헤더를 위한 공간 확보 -->
        
        <h2 class="text-xl font-semibold text-gray-700 mb-4">사용 방법</h2>
        <!-- [수정] space-y, my- : 모바일(기본)에서는 간격을 줄임 -->
        <div class="space-y-2 md:space-y-4">
            <!-- [수정] py-, text- : 모바일(기본)에서는 버튼 높이와 텍스트 크기를 줄임 -->
            <button id="draw-left" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 md:py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center justify-center text-sm md:text-base">
                <span>1. 왼쪽 조각 자르기</span>
            </button>
            <button id="draw-top" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 md:py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center justify-center text-sm md:text-base">
                <span>2. 위쪽 조각 자르기</span>
            </button>
            <button id="print" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 md:py-3 px-4 rounded-lg transition duration-200 shadow-md flex items-center justify-center text-sm md:text-base">
                <span>3. 인쇄하기</span>
            </button>
            
            <span class="block border-t border-gray-300 my-4 md:my-6"></span>
            <button id="reset" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 md:py-3 px-4 rounded-lg transition duration-200 text-sm md:text-base">
                초기화
            </button>
        </div>
    </div>
    
    <!-- 캔버스 컨테이너 (전체 화면) -->
    <div id="canvas-container"></div>

    <script>
        // === 전역 변수 설정 ===
        let tileSize = 200;   // 기본 타일 크기
        let tileX, tileY;     // 타일이 그려질 시작 위치 (중앙 정렬용)
        let controlsWidth = 0; // 컨트롤 패널 너비

        let leftCutPoints = [];  // 왼쪽 변을 따라 잘라낸 조각의 점들
        let topCutPoints = [];   // 위쪽 변을 따라 잘라낸 조각의 점들

        let leftPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };
        let topPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };

        let drawingState = 'none'; // 'left', 'top', 'none'
        let isDrawing = false;
        let showTessellation = false; // 인쇄 버튼이 눌렸는지 여부 (이제 draw()에서 직접 사용되진 않음)

        let draggingPiece = null; // 현재 드래그 중인 조각 ('leftPiece' 또는 'topPiece')
        let dragOffsetX, dragOffsetY; // 드래그 시작 시 마우스와 조각 위치의 차이

        let colorA, colorB, guideColor; // 타일 및 안내선 색상
        
        let errorMsg = ""; // 사용자에게 보여줄 안내 메시지
        let errorTimer = 0; // 메시지 타이머

        // === p5.js 스케치 ===

        const sketch = (p) => {
            
            let controlsPanel; // 컨트롤 패널 DOM 요소
            let headerEl; // 상단 헤더 DOM 요소

            p.setup = () => {
                const container = document.getElementById('canvas-container');
                let cnv = p.createCanvas(p.windowWidth, p.windowHeight); 
                cnv.parent('canvas-container');

                controlsPanel = document.getElementById('controls-panel');
                headerEl = document.querySelector('.absolute.z-20'); // 헤더 요소 선택
                
                // [수정] 헤더 높이를 읽어와서 tileY 계산
                let headerHeight = headerEl ? headerEl.offsetHeight : 80; // 헤더 실제 높이 (기본값 80)
                controlsWidth = controlsPanel.offsetWidth;

                tileX = controlsWidth + ( (p.windowWidth - controlsWidth) / 2 ) - (tileSize / 2); 
                // [수정] tileY: 헤더 높이를 제외한 영역의 세로 중앙
                tileY = headerHeight + ((p.windowHeight - headerHeight) / 2) - (tileSize / 2); 

                colorA = p.color(110, 168, 255, 200); // Blue
                colorB = p.color(255, 255, 255, 200); // White
                guideColor = p.color(220, 38, 38, 200); // Red (drawing guide)

                p.strokeWeight(2);
                p.redraw();
            };

            p.draw = () => {
                p.clear(); // 캔버스를 투명하게 지움
                p.background(241, 245, 249); // bg-gray-100 (CSS와 동일)

                // 1. 점 그리드 그리기
                drawGrid();

                // 2. 실시간 테셀레이션 윤곽선 그리기
                drawTessellation(false); // 채우기(fill) 없이 윤곽선만

                // 3. 중앙 작업 타일 그리기 (항상 맨 위에)
                drawConstruction();

                // 4. 상태 메시지 그리기
                drawStatusText();
                
                if (errorTimer > 0) {
                    errorTimer -= p.deltaTime;
                    if (errorTimer <= 0) {
                        errorMsg = "";
                        p.redraw(); // 메시지 지우기
                    }
                }
                
                // p5.js 루프를 멈추고, 변경 사항이 있을 때만 redraw() 호출
                p.noLoop();
            };
            
            /** 점 그리드를 그리는 함수 */
            function drawGrid() {
                p.stroke(200, 200, 200, 100); // 점 색상
                p.strokeWeight(2); // 점 크기
                
                // 중앙 타일 위치에 맞게 그리드 오프셋 조정
                let offsetX = tileX % 20;
                let offsetY = tileY % 20;

                for (let x = -offsetX; x < p.width; x += 20) {
                    for (let y = -offsetY; y < p.height; y += 20) {
                        p.point(x, y);
                    }
                }
            }

            /** 타일 모양을 그리는 핵심 함수 (채우기/윤곽선 모드) */
            function drawTileShape(ox, oy, doFill, fillColor) {
                if (doFill) {
                    p.fill(fillColor);
                    p.stroke(30); 
                    p.strokeWeight(1.5); // 인쇄 시 윤곽선
                } else {
                    p.noFill();
                    p.stroke(150, 150, 150, 100); // 실시간 윤곽선
                    p.strokeWeight(1);
                }

                p.beginShape();

                // 1. 위쪽 변
                if (topCutPoints.length === 0 || (!topPiece.snapped && !doFill)) {
                    p.vertex(ox, oy);
                    p.vertex(ox + tileSize, oy);
                } else {
                    for (let pt of topCutPoints) {
                        p.vertex(ox + pt.x, oy + pt.y);
                    }
                }

                // 2. 오른쪽 변
                if (leftCutPoints.length === 0 || (!leftPiece.snapped && !doFill)) {
                    p.vertex(ox + tileSize, oy + tileSize);
                } else {
                    for (let pt of leftCutPoints) {
                        p.vertex(ox + tileSize + pt.x, oy + pt.y);
                    }
                }

                // 3. 아래쪽 변
                if (topCutPoints.length === 0 || (!topPiece.snapped && !doFill)) {
                    p.vertex(ox, oy + tileSize);
                } else {
                    for (let i = topCutPoints.length - 1; i >= 0; i--) {
                        let pt = topCutPoints[i];
                        p.vertex(ox + pt.x, oy + tileSize + pt.y);
                    }
                }

                // 4. 왼쪽 변
                if (leftCutPoints.length === 0 || (!leftPiece.snapped && !doFill)) {
                    p.vertex(ox, oy);
                } else {
                    for (let i = leftCutPoints.length - 1; i >= 0; i--) {
                        let pt = leftCutPoints[i];
                        p.vertex(ox + pt.x, oy + pt.y);
                    }
                }

                p.endShape(p.CLOSE);
                p.noFill();
            }

            /** 그리기 및 조각 이동 과정을 보여주는 함수 (중앙 타일) */
            function drawConstruction() {
                p.push(); // 좌표계 저장
                p.translate(tileX, tileY); // 중앙 타일 위치로 원점 이동

                // 사각형 채우기 (기본 타일)
                p.fill(colorA);
                p.noStroke();
                // p.rect(0, 0, tileSize, tileSize); // rect 대신 shape 사용
                
                // Cut-out area drawing (항상 채워진 모양)
                p.fill(colorA);
                p.stroke(p.color(50,50,50,150));
                p.strokeWeight(2.5); // 더 굵게
                
                p.beginShape();
                // (0,0) 시작
                if (topCutPoints.length > 0 && topPiece.snapped) {
                    for (let pt of topCutPoints) {
                        p.vertex(pt.x, pt.y);
                    }
                } else {
                    p.vertex(0, 0);
                    p.vertex(tileSize, 0);
                }
                
                // 우측 변
                if (leftCutPoints.length > 0 && leftPiece.snapped) {
                     for (let pt of leftCutPoints) {
                        p.vertex(tileSize + pt.x, pt.y);
                    }
                } else {
                    p.vertex(tileSize, tileSize);
                }

                // 하단 변
                if (topCutPoints.length > 0 && topPiece.snapped) {
                    for (let i = topCutPoints.length - 1; i >= 0; i--) {
                        let pt = topCutPoints[i];
                        p.vertex(pt.x, tileSize + pt.y);
                    }
                } else {
                    p.vertex(0, tileSize);
                }
                
                // 좌측 변
                if (leftCutPoints.length > 0 && leftPiece.snapped) {
                    for (let i = leftCutPoints.length - 1; i >= 0; i--) {
                        let pt = leftCutPoints[i];
                        p.vertex(pt.x, pt.y);
                    }
                } else {
                    p.vertex(0, 0);
                }
                p.endShape(p.CLOSE);

                // --- 조각 그리기 (leftPiece) ---
                if (leftCutPoints.length > 0 && !leftPiece.snapped) {
                    p.push();
                    p.translate(leftPiece.x, leftPiece.y); // 조각의 현재 위치로 이동
                    if (draggingPiece === leftPiece) {
                        p.fill(p.color(59, 130, 246, 150)); 
                        p.stroke(p.color(59, 130, 246));
                        p.strokeWeight(3.5); // 더 굵게
                    } else {
                        p.fill(p.color(59, 130, 246, 200)); // 파란색
                        p.stroke(p.color(59, 130, 246));
                        p.strokeWeight(2.5);
                    }
                    drawPieceShape(leftCutPoints);
                    p.pop();
                }

                // --- 조각 그리기 (topPiece) ---
                if (topCutPoints.length > 0 && !topPiece.snapped) {
                    p.push();
                    p.translate(topPiece.x, topPiece.y); // 조각의 현재 위치로 이동
                    if (draggingPiece === topPiece) {
                        p.fill(p.color(34, 197, 94, 150)); 
                        p.stroke(p.color(34, 197, 94));
                        p.strokeWeight(3.5); // 더 굵게
                    } else {
                        p.fill(p.color(34, 197, 94, 200)); // 초록색
                        p.stroke(p.color(34, 197, 94));
                        p.strokeWeight(2.5);
                    }
                    drawPieceShape(topCutPoints);
                    p.pop();
                }

                // 현재 그리기 모드에 따라 안내선 강조
                p.strokeWeight(3.5); // 더 굵게
                p.stroke(guideColor);
                p.noFill();
                p.drawingContext.setLineDash([8, 8]); // 점선
                if (drawingState === 'left') {
                    p.line(0, 0, 0, tileSize);
                } else if (drawingState === 'top') {
                    p.line(0, 0, tileSize, 0);
                }
                p.drawingContext.setLineDash([]); // 점선 해제
                
                p.pop(); // 원점 복구
            }

            /** 주어진 점들로 다각형을 그리는 헬퍼 함수 */
            function drawPieceShape(points) {
                p.beginShape();
                for (let pt of points) {
                    p.vertex(pt.x, pt.y);
                }
                p.endShape(p.CLOSE);
            }

            /** 테셀레이션 모드일 때 타일 반복해서 그리기 */
            function drawTessellation(doFill) {
                // tileX, tileY 기준으로 그리드 정렬
                let startX = tileX % tileSize;
                let startY = tileY % tileSize;
                
                // 캔버스 밖까지 그리도록 범위 확장
                for (let y = -startY - tileSize; y < p.height; y += tileSize) {
                    for (let x = -startX - tileSize; x < p.width; x += tileSize) {
                        let color = ((Math.floor(x / tileSize) + Math.floor(y / tileSize)) % 2 === 0) ? colorA : colorB;
                        drawTileShape(x, y, doFill, color);
                    }
                }
            }

            /** 상태 메시지 업데이트 (캔버스에 직접 그리기) */
            function drawStatusText() {
                let msg = errorMsg; // 에러 메시지를 우선 표시

                if (msg === "") { // 에러가 없으면 상태 메시지 표시
                    if (drawingState === 'left') {
                        msg = '왼쪽 변을 따라 자유롭게 선을 그려보세요.';
                    } else if (drawingState === 'top') {
                        msg = '위쪽 변을 따라 자유롭게 선을 그려보세요.';
                    } else if (draggingPiece === leftPiece) {
                        msg = '파란색 조각을 오른쪽으로 드래그하여 붙이세요.';
                    } else if (draggingPiece === topPiece) {
                        msg = '초록색 조각을 아래쪽으로 드래그하여 붙이세요.';
                    } else if (leftCutPoints.length > 0 && !leftPiece.snapped) {
                        msg = '파란색 조각을 클릭하여 오른쪽으로 이동하세요.';
                    } else if (topCutPoints.length > 0 && !topPiece.snapped) {
                        msg = '초록색 조각을 클릭하여 아래쪽으로 이동하세요.';
                    } else if (leftPiece.snapped && topPiece.snapped) {
                        msg = '완성되었습니다! 인쇄 버튼을 누르세요.';
                    }
                }

                if (msg) {
                    p.push();
                    p.translate(tileX, tileY); // 중앙 타일 기준
                    p.fill(guideColor); // 빨간색
                    p.noStroke();
                    p.textAlign(p.CENTER, p.BOTTOM);
                    p.textSize(16);
                    p.textStyle(p.BOLD);
                    p.text(msg, tileSize / 2, -60); // [수정] 기존 -30 -> -60으로 더 올림
                    p.pop();
                }
            }

            // === p5.js 마우스 이벤트 핸들러 ===

            p.mousePressed = (event) => {
                // UI 클릭 시 캔버스 이벤트 무시
                if (event.target.closest('#controls-panel') || event.target.closest('.absolute.z-20')) {
                    return;
                }
                
                const mx = p.mouseX - tileX; // 타일 기준 마우스 X
                const my = p.mouseY - tileY; // 타일 기준 마우스 Y

                if (drawingState !== 'none') {
                    // 그리기 모드
                    isDrawing = true;
                    if (drawingState === 'left') {
                        leftCutPoints = [];
                        leftCutPoints.push({ x: 0, y: 0 }); // 시작점 (0, 0)
                    } else if (drawingState === 'top') {
                        topCutPoints = [];
                        topCutPoints.push({ x: 0, y: 0 }); // 시작점 (0, 0)
                    }
                } else {
                    // 드래그 모드
                    // [수정] 조각 클릭 판정 버그 수정
                    // 각 조각의 실제 크기를 기반으로 충돌 영역 계산
                    
                    let leftCheckWidth = p.max(tileSize / 2, leftPiece.width * 1.5); // 판정 영역을 너비에 비례해 넓힘
                    let leftCheckHeight = p.max(tileSize / 2, leftPiece.height);
                    
                    if (leftCutPoints.length > 0 && !leftPiece.snapped && p.abs(mx - leftPiece.x) < leftCheckWidth && p.abs(my - leftPiece.y) < leftCheckHeight) { 
                        draggingPiece = leftPiece;
                        dragOffsetX = mx - leftPiece.x; dragOffsetY = my - leftPiece.y;
                    } else { 
                        // [수정] topPiece의 너비(width)와 높이(height)를 사용하도록 수정
                        let topCheckWidth = p.max(tileSize / 2, topPiece.width);
                        let topCheckHeight = p.max(tileSize / 2, topPiece.height * 1.5); // 판정 영역을 높이에 비례해 넓힘
                        
                        if (topCutPoints.length > 0 && !topPiece.snapped && p.abs(mx - topPiece.x) < topCheckWidth && p.abs(my - topPiece.y) < topCheckHeight) { 
                            draggingPiece = topPiece;
                            dragOffsetX = mx - topPiece.x; dragOffsetY = my - topPiece.y;
                        }
                    }
                }
                p.redraw();
            };

            p.mouseDragged = () => {
                // 마우스가 캔버스 밖으로 나가도 계속 그리거나 드래그할 수 있게 함
                
                const mx = p.mouseX - tileX;
                const my = p.mouseY - tileY;

                if (isDrawing) {
                    // 잘라내기 선 그리기 (영역 제한)
                    if (drawingState === 'left') {
                        let constrainedX = p.constrain(mx, -tileSize / 2, tileSize / 2); // 좌우 50%
                        let constrainedY = p.constrain(my, 0, tileSize); // 상하 100%
                        leftCutPoints.push({ x: constrainedX, y: constrainedY });
                    } else if (drawingState === 'top') {
                        let constrainedX = p.constrain(mx, 0, tileSize); // 좌우 100%
                        let constrainedY = p.constrain(my, -tileSize / 2, tileSize / 2); // 상하 50%
                        topCutPoints.push({ x: constrainedX, y: constrainedY });
                    }
                } else if (draggingPiece) {
                    // 조각 드래그
                    if (draggingPiece === leftPiece) {
                        draggingPiece.x = mx - dragOffsetX;
                        draggingPiece.y = my - dragOffsetY;
                        // y축 이동 제한 (0에서 tileSize까지)
                        draggingPiece.y = p.constrain(draggingPiece.y, 0, tileSize - leftPiece.height); 
                        // x축은 이동만
                        draggingPiece.x = p.constrain(draggingPiece.x, -tileSize / 2, tileSize); // 왼쪽으로 너무 멀리 가지 않도록 제한
                        
                        // 스냅 로직
                        if (p.abs(draggingPiece.x - tileSize) < 20) { // 오른쪽 변에 가까워지면
                            draggingPiece.x = tileSize;
                            draggingPiece.snapped = true;
                        } else {
                            draggingPiece.snapped = false;
                        }
                    } else if (draggingPiece === topPiece) {
                        draggingPiece.x = mx - dragOffsetX;
                        draggingPiece.y = my - dragOffsetY;
                        // x축 이동 제한 (0에서 tileSize까지)
                        draggingPiece.x = p.constrain(draggingPiece.x, 0, tileSize - topPiece.width);
                        // y축은 이동만
                        draggingPiece.y = p.constrain(draggingPiece.y, -tileSize / 2, tileSize); // 위쪽으로 너무 멀리 가지 않도록 제한

                        // 스냅 로직
                        if (p.abs(draggingPiece.y - tileSize) < 20) { // 아래쪽 변에 가까워지면
                            draggingPiece.y = tileSize;
                            draggingPiece.snapped = true;
                        } else {
                            draggingPiece.snapped = false;
                        }
                    }
                }
                p.redraw();
            };

            p.mouseReleased = () => {
                if (isDrawing) {
                    if (drawingState === 'left') {
                        leftCutPoints.push({ x: 0, y: tileSize }); // 끝점 (0, H)
                        // 조각의 초기 위치 설정
                        leftPiece.points = leftCutPoints;
                        leftPiece.x = 0; // 초기 위치
                        leftPiece.y = 0;
                        leftPiece.width = p.max(leftCutPoints.map(pt => pt.x)) - p.min(leftCutPoints.map(pt => pt.x));
                        leftPiece.height = tileSize;
                    } else if (drawingState === 'top') {
                        topCutPoints.push({ x: tileSize, y: 0 }); // 끝점 (W, 0)
                        // 조각의 초기 위치 설정
                        topPiece.points = topCutPoints;
                        topPiece.x = 0; // 초기 위치
                        topPiece.y = 0;
                        topPiece.width = tileSize;
                        topPiece.height = p.max(topCutPoints.map(pt => pt.y)) - p.min(topCutPoints.map(pt => pt.y));
                    }
                    drawingState = 'none';
                    isDrawing = false;
                } else if (draggingPiece) {
                    if (!draggingPiece.snapped) {
                        // 스냅 안 되면 원래 위치로 (옵션)
                        draggingPiece.x = 0;
                        draggingPiece.y = 0;
                    }
                    draggingPiece = null;
                }
                p.redraw();
            };

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                
                // [수정] 창 크기 조절 시에도 헤더 높이와 패널 너비를 다시 계산
                let headerHeight = headerEl ? headerEl.offsetHeight : 80;
                controlsWidth = controlsPanel.offsetWidth; 
                
                tileX = controlsWidth + ( (p.windowWidth - controlsWidth) / 2 ) - (tileSize / 2);
                // [수정] tileY: 헤더 높이를 제외한 영역의 세로 중앙
                tileY = headerHeight + ((p.windowHeight - headerHeight) / 2) - (tileSize / 2);
                
                p.redraw(); 
            };
            
            // === [신규] 모바일 터치 이벤트 핸들러 ===
            // 터치 이벤트가 발생하면, 기존의 마우스 이벤트 함수를 호출합니다.
            
            p.touchStarted = (event) => {
                // UI 클릭 시 캔버스 이벤트 무시
                if (event.target.closest('#controls-panel') || event.target.closest('.absolute.z-20')) {
                    return true; // 기본 동작 허용 (스크롤 등)
                }

                const mx = p.mouseX - tileX; 
                const my = p.mouseY - tileY; 

                if (drawingState !== 'none') {
                    isDrawing = true;
                    if (drawingState === 'left') {
                        leftCutPoints = [{ x: 0, y: 0 }]; 
                    } else if (drawingState === 'top') {
                        topCutPoints = [{ x: 0, y: 0 }]; 
                    }
                } else {
                    // [수정] 조각 클릭 판정 버그 수정 (마우스와 동일)
                    let leftCheckWidth = p.max(tileSize / 2, leftPiece.width * 1.5);
                    let leftCheckHeight = p.max(tileSize / 2, leftPiece.height);
                    
                    if (leftCutPoints.length > 0 && !leftPiece.snapped && p.abs(mx - leftPiece.x) < leftCheckWidth && p.abs(my - leftPiece.y) < leftCheckHeight) { 
                        draggingPiece = leftPiece;
                        dragOffsetX = mx - leftPiece.x; dragOffsetY = my - leftPiece.y;
                    } else { 
                        let topCheckWidth = p.max(tileSize / 2, topPiece.width);
                        let topCheckHeight = p.max(tileSize / 2, topPiece.height * 1.5);
                        
                        if (topCutPoints.length > 0 && !topPiece.snapped && p.abs(mx - topPiece.x) < topCheckWidth && p.abs(my - topPiece.y) < topCheckHeight) { 
                            draggingPiece = topPiece;
                            dragOffsetX = mx - topPiece.x; dragOffsetY = my - topPiece.y;
                        }
                    }
                }
                p.redraw();

                return false; // 페이지 스크롤 등 기본 터치 동작 방지
            };

            p.touchMoved = (event) => {
                // UI 위에서 터치 이동 시 기본 스크롤 허용
                if (event.target.closest('#controls-panel') || event.target.closest('.absolute.z-20')) {
                    return true;
                }

                const mx = p.mouseX - tileX;
                const my = p.mouseY - tileY;

                if (isDrawing) {
                    if (drawingState === 'left') {
                        let constrainedX = p.constrain(mx, -tileSize / 2, tileSize / 2); 
                        let constrainedY = p.constrain(my, 0, tileSize); 
                        leftCutPoints.push({ x: constrainedX, y: constrainedY });
                    } else if (drawingState === 'top') {
                        let constrainedX = p.constrain(mx, 0, tileSize); 
                        let constrainedY = p.constrain(my, -tileSize / 2, tileSize / 2); 
                        topCutPoints.push({ x: constrainedX, y: constrainedY });
                    }
                } else if (draggingPiece) {
                    if (draggingPiece === leftPiece) {
                        draggingPiece.x = mx - dragOffsetX;
                        draggingPiece.y = my - dragOffsetY;
                        draggingPiece.y = p.constrain(draggingPiece.y, 0, tileSize - leftPiece.height); 
                        draggingPiece.x = p.constrain(draggingPiece.x, -tileSize / 2, tileSize); 
                        if (p.abs(draggingPiece.x - tileSize) < 20) { 
                            draggingPiece.x = tileSize; draggingPiece.snapped = true;
                        } else { draggingPiece.snapped = false; }
                    } else if (draggingPiece === topPiece) {
                        draggingPiece.x = mx - dragOffsetX;
                        draggingPiece.y = my - dragOffsetY;
                        draggingPiece.x = p.constrain(draggingPiece.x, 0, tileSize - topPiece.width);
                        draggingPiece.y = p.constrain(draggingPiece.y, -tileSize / 2, tileSize); 
                        if (p.abs(draggingPiece.y - tileSize) < 20) { 
                            draggingPiece.y = tileSize; draggingPiece.snapped = true;
                        } else { draggingPiece.snapped = false; }
                    }
                }
                p.redraw();

                return false; // 페이지 스크롤 등 기본 터치 동작 방지
            };
            
            p.touchEnded = (event) => {
                // UI 위에서 터치 종료 시 기본 동작 허용
                if (event.target.closest('#controls-panel') || event.target.closest('.absolute.z-20')) {
                    return true;
                }

                if (isDrawing) {
                    if (drawingState === 'left') {
                        leftCutPoints.push({ x: 0, y: tileSize }); 
                        leftPiece.points = leftCutPoints;
                        leftPiece.x = 0; leftPiece.y = 0;
                        leftPiece.width = p.max(leftCutPoints.map(pt => pt.x)) - p.min(leftCutPoints.map(pt => pt.x));
                        leftPiece.height = tileSize;
                    } else if (drawingState === 'top') {
                        topCutPoints.push({ x: tileSize, y: 0 }); 
                        topPiece.points = topCutPoints;
                        topPiece.x = 0; topPiece.y = 0;
                        topPiece.width = tileSize;
                        topPiece.height = p.max(topCutPoints.map(pt => pt.y)) - p.min(topCutPoints.map(pt => pt.y));
                    }
                    drawingState = 'none';
                    isDrawing = false;
                } else if (draggingPiece) {
                    if (!draggingPiece.snapped) {
                        draggingPiece.x = 0; draggingPiece.y = 0; 
                    }
                    draggingPiece = null;
                }
                p.redraw();

                return false; // 페이지 스크롤 등 기본 터치 동작 방지
            };

            // === [신규] 인쇄 로직 (스케치 내부 함수) ===
            p.triggerPrint = () => {
                if (!leftPiece.snapped || !topPiece.snapped) {
                    setErrorMessage("모든 조각을 이동시켜야 인쇄할 수 있습니다.");
                    return;
                }
                
                // 인쇄용 전체 화면 그리기 (p5.js 루프를 임시로 재시작)
                p.loop(); // 루프 시작
                p.clear();
                p.background(255); // 흰색 배경
                // [수정] 오타 수정: drawTSessellation -> drawTessellation
                drawTessellation(true); // 채워진 테셀레이션 그리기
                p.noLoop(); // 그리기 완료 후 루프 정지
                
                window.print(); // 인쇄 대화상자 열기
                
                // 인쇄 후 원래 상태로 복구 (루프 정지 및 다시 그리기)
                p.clear();
                p.redraw(); // draw() 함수 1회 호출
            };


        }; // End of sketch function

        let myp5 = new p5(sketch);

        // === HTML 버튼 이벤트 핸들러 ===
        
        function setErrorMessage(msg) {
            errorMsg = msg;
            errorTimer = 3000; // 3초
            myp5.redraw();
        }

        document.getElementById('draw-left').addEventListener('click', () => {
            if (drawingState !== 'none') return;
            if (showTessellation) showTessellation = false;
            
            drawingState = 'left';
            leftCutPoints = []; // 리셋
            leftPiece.snapped = false;
            leftPiece.x = 0; leftPiece.y = 0; // 조각 위치 리셋
            myp5.redraw();
        });

        document.getElementById('draw-top').addEventListener('click', () => {
            if (drawingState !== 'none') return;
            if (!leftPiece.snapped) {
                setErrorMessage("먼저 왼쪽 조각을 오른쪽으로 이동시켜야 합니다.");
                return;
            }
            if (showTessellation) showTessellation = false;

            drawingState = 'top';
            topCutPoints = []; // 리셋
            topPiece.snapped = false;
            topPiece.x = 0; topPiece.y = 0; // 조각 위치 리셋
            myp5.redraw();
        });

        document.getElementById('print').addEventListener('click', () => {
            // [수정] 스케치 내부에 정의된 triggerPrint 함수를 호출
            myp5.triggerPrint();
        });

        document.getElementById('reset').addEventListener('click', () => {
            leftCutPoints = [];
            topCutPoints = [];
            leftPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };
            topPiece = { points: [], x: 0, y: 0, width: 0, height: 0, active: false, snapped: false };
            drawingState = 'none';
            isDrawing = false;
            showTessellation = false;
            draggingPiece = null;
            errorMsg = ""; // 메시지 초기화
            errorTimer = 0;
            myp5.redraw(); 
        });

    </script>
</body>
</html>


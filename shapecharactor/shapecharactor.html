<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>나만의 도형 캐릭터 만들기</title>
    <!-- Tailwind CSS 로드 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fabric.js 로드 (캔버스 라이브러리) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <!-- Google Fonts (Inter) 로드 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 폰트 및 배경 설정 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* bg-gray-100 */
        }
        /* 활성화된 탭 스타일 */
        .tab-active {
            border-color: #8b5cf6; /* violet-500 */
            background-color: #ede9fe; /* violet-100 */
            color: #5b21b6; /* violet-800 */
            font-weight: 600;
        }
        /* 파츠 아이템 호버 스타일 */
        .part-item:hover {
            transform: scale(1.08) rotate(3deg);
            background-color: #e0e7ff;
        }
        /* Fabric.js 컨트롤 커스텀 스타일 */
        .canvas-container {
            border-radius: 1rem; /* rounded-2xl */
        }
        /* 스크롤바 스타일링 */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px;}
        ::-webkit-scrollbar-thumb { background: #a78bfa; border-radius: 10px;} /* violet-400 */
        ::-webkit-scrollbar-thumb:hover { background: #7c3aed; } /* violet-600 */
        /* 관리자용 파츠 삭제 버튼 스타일 */
        .admin-delete-btn {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 24px;
            height: 24px;
            background-color: #ef4444; /* red-500 */
            color: white;
            border-radius: 9999px; /* rounded-full */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s, transform 0.2s;
            border: 2px solid white;
            transform: scale(0.9);
        }
        .admin-delete-btn:hover {
            opacity: 1;
            transform: scale(1);
        }
        /* 레이어 아이템 스타일 */
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            margin-bottom: 4px;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            user-select: none;
            transition: all 0.2s ease-in-out;
        }
        .layer-item.selected {
            background-color: #ede9fe;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 2px #c4b5fd;
        }
        .layer-item.dragging {
            opacity: 0.5;
            background: #c7d2fe;
        }
        .layer-item-name {
            flex-grow: 1;
            margin: 0 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: default;
        }
        .layer-item-controls button {
            margin-left: 4px;
            color: #9ca3af;
            transition: color 0.2s;
        }
        .layer-item-controls button:hover {
            color: #374151;
        }
        .layer-item-controls .toggled-on svg {
            color: #8b5cf6;
        }
        .layer-item-controls .locked svg {
            color: #f43f5e;
        }
        .layer-item-drag-handle {
            cursor: grab;
            color: #d1d5db;
        }
        .tool-btn {
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .tool-btn:active {
            transform: translateY(0);
            box-shadow: none;
        }
    </style>
</head>
<body class="w-screen h-screen overflow-hidden flex flex-col">

    <!-- ① 헤더 -->
    <header class="bg-white/80 backdrop-blur-lg border-b border-gray-200 p-3 flex items-center justify-center z-10 shrink-0">
        <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-violet-500"><path d="M12 22s-8-4.5-8-11.8A8 8 0 0 1 12 2a8 8 0 0 1 8 8.2c0 7.3-8 11.8-8 11.8z"/><circle cx="12" cy="10" r="3"/></svg>
        <h1 class="text-xl font-bold ml-2 text-gray-800">나만의 도형 캐릭터 만들기</h1>
    </header>

    <!-- 메인 영역 -->
    <main class="flex-1 flex flex-col lg:flex-row p-2 lg:p-4 gap-4 overflow-hidden">
        
        <!-- ② 파츠/레이어 패널 (데스크톱) -->
        <aside class="w-full lg:w-72 h-full flex-col shrink-0 order-2 lg:order-1 hidden lg:flex gap-4">
            <!-- 파츠 & 업로드 섹션 -->
            <div class="bg-white/80 backdrop-blur-lg rounded-2xl shadow-lg shadow-gray-500/5 flex flex-col flex-[2] min-h-0">
                <div class="p-3 border-b border-gray-200"><h2 class="font-semibold text-gray-700">파츠 선택</h2></div>
                <div class="flex border-b border-gray-200">
                    <button id="tab-shapes" class="flex-1 p-3 text-sm text-gray-600 border-b-2 tab-active">도형</button>
                    <button id="tab-lines" class="flex-1 p-3 text-sm text-gray-600 border-b-2 border-transparent">선</button>
                </div>
                <div id="parts-container" class="p-3 overflow-y-auto flex-1">
                    <!-- 파츠가 동적으로 이곳에 추가됩니다. -->
                </div>
                <!-- 파일 업로드 섹션 -->
                <div class="p-3 border-t border-gray-200 flex flex-col gap-2">
                    <input type="file" id="svg-upload-input" class="hidden" accept=".svg">
                    <button id="upload-btn" class="w-full bg-violet-500 text-white px-4 py-2 rounded-lg shadow-md shadow-violet-500/20 hover:bg-violet-600 transition-all text-sm font-semibold flex items-center justify-center gap-2 transform hover:-translate-y-px">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                        SVG 캔버스에 추가
                    </button>
                    <input type="file" id="admin-svg-upload-input" class="hidden" accept=".svg">
                    <button id="admin-upload-btn" class="w-full bg-green-600 text-white px-4 py-2 rounded-lg shadow-md shadow-green-500/20 hover:bg-green-700 transition-all text-sm font-semibold items-center justify-center gap-2 hidden transform hover:-translate-y-px">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><line x1="19" y1="8" x2="19" y2="14"/><line x1="22" y1="11" x2="16" y2="11"/></svg>
                        SVG 파츠로 추가
                    </button>
                    <p class="text-xs text-center text-gray-400 hidden" id="admin-mode-text">관리자 모드 활성화됨</p>
                </div>
            </div>
            
            <!-- 레이어 섹션 -->
            <div class="bg-white/80 backdrop-blur-lg rounded-2xl shadow-lg shadow-gray-500/5 flex-1 flex flex-col min-h-0 flex-[1]">
                <div class="p-3 border-b border-gray-200"><h2 class="font-semibold text-gray-700">레이어</h2></div>
                <div id="layer-list-desktop" class="flex-1 p-2 overflow-y-auto">
                    <!-- 데스크톱 레이어 목록이 이곳에 표시됩니다. -->
                </div>
            </div>
        </aside>

        <!-- ③ 스케치북 & ④ 도구 모음 영역 -->
        <div class="flex-1 flex flex-col gap-2 overflow-hidden order-1 lg:order-2">
            <div class="relative w-full flex-1 min-h-0">
                <div id="sketchbook-wrapper" class="w-full h-full bg-white rounded-2xl shadow-inner">
                    <canvas id="sketchbook"></canvas>
                    <div class="absolute top-3 right-3 flex gap-2 z-10">
                        <button id="save-all-btn" class="bg-gray-800 text-white px-4 py-2 rounded-lg shadow-lg shadow-gray-800/20 hover:bg-black transition-all text-sm font-semibold flex items-center gap-2 transform hover:-translate-y-px">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                            전체 저장
                        </button>
                        <button id="save-selected-btn" class="bg-violet-500 hover:bg-violet-600 text-white px-4 py-2 rounded-lg shadow-lg shadow-violet-500/20 transition-all text-sm font-semibold flex items-center gap-2 disabled:bg-gray-300 disabled:text-gray-500 disabled:cursor-not-allowed disabled:shadow-none transform disabled:transform-none hover:-translate-y-px" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                            선택 저장
                        </button>
                    </div>
                </div>
            </div>
            <div class="flex justify-center shrink-0">
                <div class="bg-white/60 backdrop-blur-xl p-2 rounded-2xl shadow-lg shadow-gray-500/10 flex items-center gap-1">
                    <button id="draw-curve-btn" class="tool-btn p-3 rounded-xl hover:bg-violet-100 transition-colors flex items-center gap-2" title="자유 곡선 그리기">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-700"><path d="M20.42 10.18c.62-.28 1.12-.89 1.2-1.62.1-1.04-.62-2.1-1.68-2.32-1.04-.22-2.1.62-2.32 1.68-.08.38.02.78.22 1.12"/><path d="M14.93 17.58c1.56-.63 2.68-2.32 2.68-4.12 0-2.4-1.92-4.38-4.38-4.38-1.8 0-3.4.94-4.12 2.68"/><path d="M3.58 11.58c-.63 1.56-2.32 2.68-4.12 2.68C-2.4 14.26-4.38 12.34-4.38 9.9c0-1.8.94-3.4 2.68-4.12"/><path d="M10.18 3.58c.34.1.68.22 1.02.42"/><path d="M2.1 16.2c.4.18.82.32 1.28.42"/><path d="M21.9 7.8c-.18.4-.32.82-.42 1.28"/><path d="M17.58 14.93c-.63 1.56-2.32 2.68-4.12 2.68-2.4 0-4.38-1.92-4.38-4.38 0-1.8.94-3.4 2.68-4.12"/></svg>
                        <span class="font-semibold text-sm text-gray-700 hidden sm:inline">도형 그리기</span>
                    </button>
                    <button id="draw-line-btn" class="tool-btn p-3 rounded-xl hover:bg-violet-100 transition-colors flex items-center gap-2" title="선 그리기">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-700"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3 16.828V21h4.172l14.002-14.002z"/><path d="m15 5 6 6"/></svg>
                        <span class="font-semibold text-sm text-gray-700 hidden sm:inline">선 그리기</span>
                    </button>
                    <div class="border-l border-gray-200 h-6 mx-1"></div>
                    <button id="group-btn" class="tool-btn p-3 rounded-xl hover:bg-violet-100 transition-colors flex items-center gap-2 hidden" title="그룹 만들기">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-700"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                        <span class="font-semibold text-sm text-gray-700 hidden sm:inline">그룹</span>
                    </button>
                    <button id="ungroup-btn" class="tool-btn p-3 rounded-xl hover:bg-violet-100 transition-colors flex items-center gap-2 hidden" title="그룹 해제">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-700"><path d="M21 12H3"/><path d="M12 21V3"/></svg>
                        <span class="font-semibold text-sm text-gray-700 hidden sm:inline">그룹 해제</span>
                    </button>
                     <button id="panel-btn-mobile" class="tool-btn p-3 rounded-xl hover:bg-violet-100 transition-colors flex items-center gap-2 lg:hidden" title="파츠/레이어 보기">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-700"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>
                        <span class="font-semibold text-sm text-gray-700 hidden sm:inline">파츠/레이어</span>
                    </button>
                    <button id="stop-drawing-btn" class="tool-btn p-3 rounded-lg hover:bg-violet-100 transition-colors hidden" title="그리기 중단">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-red-500"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <!-- UI 오버레이들 -->
    <div id="color-palette-context-menu" class="fixed hidden z-50">
        <div class="bg-white p-3 rounded-xl shadow-2xl border border-gray-200">
            <div id="color-grid" class="grid grid-cols-8 gap-2"></div>
        </div>
    </div>
    <div id="save-preview-modal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center hidden z-50">
        <div class="bg-white p-5 rounded-xl shadow-2xl w-11/12 max-w-lg flex flex-col">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-gray-800">이미지 저장 미리보기</h3>
                <button id="close-preview-btn" class="text-gray-500 hover:text-gray-800">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <p class="text-sm text-gray-600 mb-3">빨간 중심점을 드래그하여 이미지의 중심을 맞추세요. 중심점에 따라 이미지가 자동으로 잘립니다.</p>
            <div id="preview-container" class="w-full bg-gray-100 rounded-lg relative overflow-hidden mb-4" style="aspect-ratio: 1/1;">
                <img id="preview-image" src="" alt="저장 미리보기" class="w-full h-full object-contain">
                <div id="center-point" class="absolute w-8 h-8 cursor-move select-none" style="transform: translate(-50%, -50%);">
                    <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="50" cy="50" r="45" stroke="#ef4444" stroke-width="8" stroke-dasharray="10 5"/>
                        <circle cx="50" cy="50" r="10" fill="#ef4444"/>
                    </svg>
                </div>
            </div>
            <div class="flex flex-col sm:flex-row gap-2">
                <input id="filename-input" type="text" placeholder="파일 이름" value="my-character" class="flex-1 border border-gray-300 rounded-lg px-3 py-2 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none">
                <button id="save-png-btn" class="bg-blue-600 text-white px-4 py-2 rounded-lg shadow hover:bg-blue-700 transition-colors font-semibold">PNG로 저장</button>
                <button id="save-svg-btn" class="bg-green-600 text-white px-4 py-2 rounded-lg shadow hover:bg-green-700 transition-colors font-semibold">SVG로 저장</button>
            </div>
        </div>
    </div>
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center hidden z-50">
        <div class="bg-white p-6 rounded-xl shadow-2xl w-11/12 max-w-sm text-center">
            <h3 id="confirm-title" class="text-lg font-bold text-gray-800 mb-2">삭제 확인</h3>
            <p id="confirm-message" class="text-sm text-gray-600 mb-6">선택한 항목을 삭제하시겠습니까?</p>
            <div class="flex justify-center gap-4">
                <button id="confirm-cancel-btn" class="px-6 py-2 rounded-lg bg-gray-200 hover:bg-gray-300 font-semibold">취소</button>
                <button id="confirm-ok-btn" class="px-6 py-2 rounded-lg bg-red-500 text-white hover:bg-red-600 font-semibold">삭제</button>
            </div>
        </div>
    </div>
    
    <!-- 모바일용 패널 모달 -->
    <div id="mobile-panel-modal" class="fixed inset-0 bg-black bg-opacity-40 hidden z-40 lg:hidden">
        <div id="mobile-panel-sheet" class="absolute bottom-0 left-0 right-0 bg-white rounded-t-2xl shadow-2xl flex flex-col transition-transform translate-y-full" style="height: 70vh;">
            <div class="p-2 border-b border-gray-200 flex justify-between items-center shrink-0">
                 <div class="flex border-b border-gray-200 w-full">
                    <button id="tab-shapes-mobile" class="flex-1 p-3 text-sm text-gray-600 border-b-2 tab-active">도형</button>
                    <button id="tab-lines-mobile" class="flex-1 p-3 text-sm text-gray-600 border-b-2 border-transparent">선</button>
                    <button id="tab-layers-mobile" class="flex-1 p-3 text-sm text-gray-600 border-b-2 border-transparent">레이어</button>
                </div>
                <button id="close-panel-modal-btn" class="text-gray-500 hover:text-gray-800 ml-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
            <div id="mobile-panel-content" class="flex-1 overflow-y-auto p-2">
                 <!-- Mobile panel content will be populated here -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM 요소 참조 ---
            const canvasEl = document.getElementById('sketchbook');
            const sketchbookWrapper = document.getElementById('sketchbook-wrapper');
            const partsContainer = document.getElementById('parts-container');
            const tabs = {
                shapes: document.getElementById('tab-shapes'),
                lines: document.getElementById('tab-lines'),
            };
            const toolBtns = {
                drawCurve: document.getElementById('draw-curve-btn'),
                drawLine: document.getElementById('draw-line-btn'),
                stopDrawing: document.getElementById('stop-drawing-btn'),
                panelMobile: document.getElementById('panel-btn-mobile'),
                group: document.getElementById('group-btn'),
                ungroup: document.getElementById('ungroup-btn'),
            };
            const layerListDesktopContainer = document.getElementById('layer-list-desktop');
            const mobilePanelModal = document.getElementById('mobile-panel-modal');
            const mobilePanelSheet = document.getElementById('mobile-panel-sheet');
            const closePanelModalBtn = document.getElementById('close-panel-modal-btn');
            const mobilePanelContent = document.getElementById('mobile-panel-content');
            const mobileTabs = {
                shapes: document.getElementById('tab-shapes-mobile'),
                lines: document.getElementById('tab-lines-mobile'),
                layers: document.getElementById('tab-layers-mobile'),
            };
            const adminUploadBtn = document.getElementById('admin-upload-btn');
            const adminSvgUploadInput = document.getElementById('admin-svg-upload-input');
            const adminModeText = document.getElementById('admin-mode-text');
            const uploadBtn = document.getElementById('upload-btn');
            const svgUploadInput = document.getElementById('svg-upload-input');
            const confirmModal = document.getElementById('confirm-modal');
            const confirmTitle = document.getElementById('confirm-title');
            const confirmMessage = document.getElementById('confirm-message');
            const confirmOkBtn = document.getElementById('confirm-ok-btn');
            const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
            const colorPaletteContextMenu = document.getElementById('color-palette-context-menu');
            const colorGrid = document.getElementById('color-grid');
            const saveSelectedBtn = document.getElementById('save-selected-btn');
            const savePreviewModal = document.getElementById('save-preview-modal');
            const closePreviewBtn = document.getElementById('close-preview-btn');
            const previewContainer = document.getElementById('preview-container');
            const previewImage = document.getElementById('preview-image');
            const centerPoint = document.getElementById('center-point');
            const filenameInput = document.getElementById('filename-input');
            const savePngBtn = document.getElementById('save-png-btn');
            const saveSvgBtn = document.getElementById('save-svg-btn');
            
            // --- 상태 변수 ---
            let objectCounter = 1;
            let isAdminMode = false;
            let confirmCallback = null;
            let currentTargetForColor = null;

            // --- 파츠 데이터 정의 ---
            const partsData = {
                shapes: [
                    { type: 'rect', options: { width: 100, height: 100, fill: '#f87171' } },
                    { type: 'circle', options: { radius: 50, fill: '#fb923c' } },
                    { type: 'triangle', options: { width: 100, height: 100, fill: '#facc15' } },
                    { type: 'path', path: 'M 50 0 L 61.2 34.5 H 98 L 73.4 55.9 L 84.5 90.5 L 50 69 L 15.5 90.5 L 26.6 55.9 L 2 34.5 H 38.8 Z', options: { fill: '#4ade80' } },
                    { type: 'path', path: 'M 50 30 C 30 10, 10 30, 10 50 C 10 70, 50 90, 50 90 C 50 90, 90 70, 90 50 C 90 30, 70 10, 50 30 Z', options: { fill: '#2dd4bf' } },
                    { type: 'path', path: 'M 20 70 A 20 20 0 0 1 20 50 C 20 30, 40 30, 50 40 C 60 30, 80 30, 80 50 A 20 20 0 0 1 80 70 Z', options: { fill: '#38bdf8' } },
                    { type: 'path', path: 'M 50 10 C 80 10, 90 40, 90 50 S 80 90, 50 90 S 20 90, 10 50 S 20 10, 50 10 Z', options: { fill: '#818cf8' } },
                    { type: 'path', path: 'M 20 50 Q 50 10, 80 50 Q 50 90, 20 50 Z', options: { fill: '#c084fc' } },
                    { type: 'path', path: 'M 40 0 H 60 V 40 H 100 V 60 H 60 V 100 H 40 V 60 H 0 V 40 H 40 Z', options: { fill: '#f87171' } },
                    { type: 'path', path: 'M 50 0 L 100 50 L 50 100 L 0 50 Z', options: { fill: '#fb923c' } },
                    { type: 'path', path: 'M 50 0 L 93.3 25 V 75 L 50 100 L 6.7 75 V 25 Z', options: { fill: '#facc15' } },
                    { type: 'path', path: 'M 10 10 Q 5 10, 5 15 V 65 Q 5 70, 10 70 H 30 L 20 85 L 40 70 H 90 Q 95 70, 95 65 V 15 Q 95 10, 90 10 Z', options: { fill: '#4ade80' } },
                    { type: 'path', path: 'M 50 0 A 50 50 0 1 0 50 100 A 40 40 0 1 1 50 0 Z', options: { fill: '#2dd4bf' } },
                    { type: 'path', path: 'M 0 0 H 100 V 100 H 0 Z M 20 20 H 80 V 80 H 20 Z', options: { fill: '#38bdf8', fillRule: 'evenodd' } },
                    { type: 'path', path: 'M 50,0 L 79.39,20.61 L 90.45,50 L 79.39,79.39 L 50,90.45 L 20.61,79.39 L 9.55,50 L 20.61,20.61 Z', options: { fill: '#818cf8' } },
                ],
                lines: [
                    { type: 'path', path: 'M 0 0 Q 50 50 100 0', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 0 50 C 25 0, 75 100, 100 50', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 0 50 Q 25 0, 50 50 T 100 50', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 10 10 C 20 80, 80 20, 90 90', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 60 0 L 40 40 L 70 40 L 30 100', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 10 90 A 80 80 0 0 1 90 90', options: { stroke: '#555555', strokeWidth: 8, fill: '', strokeDashArray: [15, 10] } },
                    { type: 'path', path: 'M 10 40 Q 50 10, 90 40 M 10 60 Q 50 90, 90 60', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 0 50 H 100 L 75 25 M 100 50 L 75 75', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 50 50 m -40 0 a 40 40 0 1 1 80 0 a 30 30 0 1 1 -60 0 a 20 20 0 1 1 40 0', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 0 0 L 100 100 M 0 100 L 100 0', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 0 50 L 25 0 L 50 50 L 75 0 L 100 50', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 0 50 H 100', options: { stroke: '#555555', strokeWidth: 8, fill: '', strokeDashArray: [10, 5] } },
                    { type: 'path', path: 'M 0 50 H 100', options: { stroke: '#555555', strokeWidth: 8, fill: '', strokeDashArray: [2, 6], strokeLineCap: 'round' } },
                    { type: 'path', path: 'M 0 50 C 25 0, 25 100, 50 50 S 75 0, 100 50', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                    { type: 'path', path: 'M 5 50 Q 25 40, 50 50 T 95 50', options: { stroke: '#555555', strokeWidth: 10, fill: '' } },
                    { type: 'path', path: 'M 25 75 L 0 50 L 25 25 M 75 25 L 100 50 L 75 75 M 0 50 H 100', options: { stroke: '#555555', strokeWidth: 8, fill: '' } },
                ],
            };
            
            // --- 색상 팔레트 데이터 ---
            const colors = ['#e11d48', '#f97316', '#f59e0b', '#84cc16', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#44403c', '#a1a1aa', '#ffffff', '#000000', '#cccccc', '#ff0000'];

            // --- Fabric.js 캔버스 초기화 ---
            const canvas = new fabric.Canvas(canvasEl, { 
                preserveObjectStacking: true,
                backgroundColor: 'rgba(255, 255, 255, 0)',
             });
            const resizeCanvas = () => {
                const { width, height } = sketchbookWrapper.getBoundingClientRect();
                canvas.setWidth(width).setHeight(height).renderAll();
            };
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            fabric.Object.prototype.transparentCorners = false;
            fabric.Object.prototype.cornerColor = '#8b5cf6';
            fabric.Object.prototype.cornerStyle = 'circle';
            fabric.Object.prototype.borderColor = '#8b5cf6';
            fabric.Object.prototype.borderDashArray = [5, 5];
            fabric.Object.prototype.cornerSize = 12;
            fabric.Object.prototype.rotatingPointOffset = 30;
            
            // --- 커스텀 속성 추가 헬퍼 함수 ---
            const addCustomProperties = (obj, namePrefix = '오브젝트') => {
                 obj.uuid = Date.now() + Math.random();
                 obj.name = `${namePrefix} ${objectCounter++}`;
                 return obj;
            };

            // --- 파츠 패널 렌더링 ---
            const renderParts = (category, container) => {
                container.innerHTML = '';
                 const grid = document.createElement('div');
                grid.className = 'grid grid-cols-3 gap-3';
                partsData[category].forEach((part, index) => {
                    const svgContainer = document.createElement('div');
                    svgContainer.className = 'part-item relative aspect-square bg-gray-100 rounded-lg flex items-center justify-center cursor-pointer transition-all p-2';
                    
                     if (part.type === 'svg') {
                        svgContainer.innerHTML = part.svgString;
                        const innerSvg = svgContainer.querySelector('svg');
                        if (innerSvg) { innerSvg.setAttribute('width', '100%'); innerSvg.setAttribute('height', '100%'); }
                    } else {
                        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                        svg.setAttribute('viewBox', '0 0 100 100');
                        svg.setAttribute('width', '100%');
                        svg.setAttribute('height', '100%');
                        
                        if (part.type === 'rect') {
                            const el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            el.setAttribute('x', 0); el.setAttribute('y', 0); el.setAttribute('width', 100); el.setAttribute('height', 100); el.setAttribute('fill', part.options.fill);
                            svg.appendChild(el);
                        } else if (part.type === 'circle') {
                            const el = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            el.setAttribute('cx', 50); el.setAttribute('cy', 50); el.setAttribute('r', 50); el.setAttribute('fill', part.options.fill);
                            svg.appendChild(el);
                        } else if (part.type === 'triangle') {
                             const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                             el.setAttribute('d', 'M 50 0 L 100 100 L 0 100 Z'); el.setAttribute('fill', part.options.fill);
                             svg.appendChild(el);
                        } else if (part.type === 'path') {
                            const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            el.setAttribute('d', part.path);
                            el.setAttribute('fill', part.options.fill || 'none');
                            el.setAttribute('stroke', part.options.stroke || 'none');
                            el.setAttribute('stroke-width', part.options.strokeWidth || 0);
                            if(part.options.fillRule) el.setAttribute('fill-rule', part.options.fillRule);
                            svg.appendChild(el);
                        } else if (part.type === 'group') {
                            part.items.forEach(item => {
                                 if (item.type === 'circle') {
                                    const el = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                                    el.setAttribute('cx', item.options.left ? item.options.left + item.options.radius : 50); 
                                    el.setAttribute('cy', item.options.top ? item.options.top + item.options.radius : 50);
                                    el.setAttribute('r', item.options.radius); el.setAttribute('fill', item.options.fill);
                                    if(item.options.stroke) el.setAttribute('stroke', item.options.stroke);
                                    if(item.options.strokeWidth) el.setAttribute('stroke-width', item.options.strokeWidth);
                                    svg.appendChild(el);
                                 } else if (item.type === 'rect') {
                                    const el = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                                    el.setAttribute('x', 25); el.setAttribute('y', 35);
                                    el.setAttribute('width', 50); el.setAttribute('height', 30); el.setAttribute('fill', item.options.fill);
                                    el.setAttribute('rx', 15); el.setAttribute('ry', 15);
                                    svg.appendChild(el);
                                 } else if (item.type === 'path') {
                                    const el = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                    el.setAttribute('d', item.options.path);
                                    el.setAttribute('fill', 'none');
                                    el.setAttribute('stroke', item.options.stroke || 'none');
                                    el.setAttribute('stroke-width', item.options.strokeWidth || 0);
                                    svg.appendChild(el);
                                 }
                            });
                        }
                        svgContainer.appendChild(svg);
                    }

                    svgContainer.addEventListener('click', () => {
                        const activeTabKey = Object.keys(tabs).find(key => tabs[key].classList.contains('tab-active')) || Object.keys(mobileTabs).find(key => mobileTabs[key].classList.contains('tab-active'));
                        const namePrefix = activeTabKey === 'lines' ? '선' : '도형';
                        addPartToCanvas(part, namePrefix);
                    });
                    
                    if (isAdminMode) {
                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'admin-delete-btn';
                        deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
                        deleteBtn.title = "파츠 삭제";
                        deleteBtn.onclick = (e) => {
                            e.stopPropagation();
                            showConfirmModal("파츠 삭제", "이 파츠를 영구적으로 삭제하시겠습니까?", () => {
                                partsData[category].splice(index, 1);
                                renderParts(category, container);
                            });
                        };
                        svgContainer.appendChild(deleteBtn);
                    }
                    grid.appendChild(svgContainer);
                });
                container.appendChild(grid);

            };

            // --- 레이어 패널 렌더링 ---
            const updateLayerList = (container) => {
                container.innerHTML = '';
                const objects = canvas.getObjects().slice().reverse();

                if (objects.length === 0) {
                    container.innerHTML = `<div class="text-center text-gray-500 p-4">레이어가 없습니다.</div>`;
                    return;
                }
                
                let draggedLayerItem = null;

                objects.forEach(obj => {
                    const item = document.createElement('div');
                    item.className = 'layer-item';
                    item.draggable = true;
                    item.dataset.uuid = obj.uuid;

                    if (canvas.getActiveObjects().includes(obj)) item.classList.add('selected');

                    const isLocked = !obj.selectable;

                    item.innerHTML = `
                        <div class="layer-item-drag-handle text-gray-400">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="currentColor" d="M12 10a2 2 0 1 1 0 4a2 2 0 0 1 0-4zm0-6a2 2 0 1 1 0 4a2 2 0 0 1 0-4zm0 12a2 2 0 1 1 0 4a2 2 0 0 1 0-4z"/></svg>
                        </div>
                        <input type="text" class="layer-item-name bg-transparent outline-none w-full" value="${obj.name || '오브젝트'}" readonly>
                        <div class="layer-item-controls flex items-center">
                            <button class="toggle-vis-btn ${obj.visible ? 'toggled-on' : ''}" title="보이기/숨기기">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                            </button>
                            <button class="toggle-lock-btn ${isLocked ? 'locked' : ''}" title="잠금/해제">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">${isLocked ? '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>' : '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 5-5v0a5 5 0 0 1 5 5v4"></path>'}</svg>
                            </button>
                            <button class="delete-layer-btn" title="레이어 삭제">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="text-red-500"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                            </button>
                        </div>
                    `;
                    container.appendChild(item);

                    const nameInput = item.querySelector('.layer-item-name');
                    const findObjectByUuid = (uuid) => canvas.getObjects().find(obj => obj.uuid == uuid);

                    item.addEventListener('click', (e) => {
                        if (e.target.closest('button') || e.target.closest('input')) return;
                        const targetObj = findObjectByUuid(obj.uuid);
                        if (targetObj) {
                            if (e.shiftKey) {
                                const activeSelection = canvas.getActiveObject();
                                if (activeSelection && activeSelection.type === 'activeSelection') {
                                    activeSelection.addWithUpdate(targetObj);
                                } else if (activeSelection) {
                                    const newSelection = new fabric.ActiveSelection([activeSelection, targetObj], { canvas: canvas });
                                    canvas.setActiveObject(newSelection);
                                }
                                canvas.renderAll();
                            } else {
                                canvas.setActiveObject(targetObj).renderAll();
                            }
                        }
                    });

                    nameInput.addEventListener('dblclick', () => { nameInput.readOnly = false; nameInput.select(); });
                    nameInput.addEventListener('blur', () => { nameInput.readOnly = true; const targetObj = findObjectByUuid(obj.uuid); if(targetObj) targetObj.name = nameInput.value; });
                    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') nameInput.blur(); });

                    item.querySelector('.toggle-vis-btn').addEventListener('click', (e) => { e.stopPropagation(); obj.set('visible', !obj.visible); canvas.renderAll(); updateAllLayerPanels();});
                    item.querySelector('.toggle-lock-btn').addEventListener('click', (e) => { e.stopPropagation(); const currentlyLocked = !obj.selectable; obj.set({ selectable: currentlyLocked, evented: currentlyLocked }); canvas.discardActiveObject().renderAll(); updateAllLayerPanels();});
                    
                    item.querySelector('.delete-layer-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        showConfirmModal('레이어 삭제', `'${obj.name}' 레이어를 삭제하시겠습니까?`, () => {
                            canvas.remove(obj);
                        });
                    });
                    
                    item.addEventListener('dragstart', () => { draggedLayerItem = item; setTimeout(() => item.classList.add('dragging'), 0); });
                    item.addEventListener('dragend', () => { if(draggedLayerItem) draggedLayerItem.classList.remove('dragging'); draggedLayerItem = null; });
                    item.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        if (item !== draggedLayerItem) {
                             const rect = item.getBoundingClientRect();
                             const next = (e.clientY - rect.top) / rect.height > .5;
                             container.insertBefore(draggedLayerItem, next && item.nextSibling || item);
                        }
                    });
                });
                
                container.addEventListener('drop', () => {
                    const newOrderUuids = Array.from(container.querySelectorAll('.layer-item')).map(it => it.dataset.uuid);
                    const totalObjects = canvas.getObjects().length;
                    
                    newOrderUuids.forEach((uuid, index) => {
                        const objToMove = canvas.getObjects().find(o => o.uuid == uuid);
                        if (objToMove) canvas.moveTo(objToMove, totalObjects - 1 - index);
                    });
                    canvas.renderAll();
                });
            };
            
            const updateAllLayerPanels = () => {
                updateLayerList(layerListDesktopContainer);
                if (!mobilePanelModal.classList.contains('hidden')) {
                     updateLayerList(mobilePanelContent);
                }
            };

            // --- 탭 전환 로직 ---
            Object.keys(tabs).forEach(key => {
                tabs[key].addEventListener('click', () => {
                    Object.values(tabs).forEach(t => t.classList.remove('tab-active'));
                    tabs[key].classList.add('tab-active');
                    renderParts(key, partsContainer); // 데스크톱 컨테이너 명시
                });
            });

            // 초기 렌더링
            renderParts('shapes', partsContainer); // 데스크톱 컨테이너 명시
            updateAllLayerPanels();

            // --- 파츠 추가 로직 ---
            const addPartToCanvas = (partData, namePrefix) => {
                let obj;
                const commonOptions = { left: canvas.width / 2, top: canvas.height / 2, originX: 'center', originY: 'center', ...partData.options, };

                switch (partData.type) {
                    case 'rect': obj = new fabric.Rect(commonOptions); break;
                    case 'circle': obj = new fabric.Circle(commonOptions); break;
                    case 'triangle': obj = new fabric.Triangle(commonOptions); break;
                    case 'path': obj = new fabric.Path(partData.path, commonOptions); break;
                    case 'group':
                        const items = partData.items.map(itemData => {
                            if (itemData.type === 'rect') return new fabric.Rect(itemData.options);
                            if (itemData.type === 'circle') return new fabric.Circle(itemData.options);
                            if (itemData.type === 'path') return new fabric.Path(itemData.options.path, itemData.options);
                            return null;
                        }).filter(Boolean);
                        obj = new fabric.Group(items, commonOptions);
                        break;
                    case 'svg':
                        fabric.loadSVGFromString(partData.svgString, (objects, options) => {
                            objects.forEach(o => { if (o.fill && typeof o.fill === 'string') { o.set('fill', '#cccccc'); } });
                            const svgObj = fabric.util.groupSVGElements(objects, options);
                            svgObj.set({ left: canvas.width / 2, top: canvas.height / 2, originX: 'center', originY: 'center'}).scaleToWidth(100);
                            addCustomProperties(svgObj, 'SVG');
                            canvas.add(svgObj).setActiveObject(svgObj).renderAll();
                        });
                        return;
                }
                
                if (obj) { addCustomProperties(obj, namePrefix); canvas.add(obj).setActiveObject(obj).renderAll(); }
            };

            // --- 색상 변경 로직 ---
            canvas.on('mouse:dblclick', (opt) => {
                opt.e.preventDefault();
                opt.e.stopPropagation();
                if (opt.target && opt.target.type !== 'activeSelection' && (opt.target.fill || opt.target.stroke || opt.target._objects)) {
                    currentTargetForColor = opt.target;
                    
                    const x = opt.e.clientX;
                    const y = opt.e.clientY;

                    colorPaletteContextMenu.style.left = `${x}px`;
                    colorPaletteContextMenu.style.top = `${y}px`;
                    colorPaletteContextMenu.classList.remove('hidden');

                    const menuRect = colorPaletteContextMenu.getBoundingClientRect();
                    if (menuRect.right > window.innerWidth) colorPaletteContextMenu.style.left = `${window.innerWidth - menuRect.width - 10}px`;
                    if (menuRect.bottom > window.innerHeight) colorPaletteContextMenu.style.top = `${window.innerHeight - menuRect.height - 10}px`;
                }
            });

            colorGrid.innerHTML = colors.map(color => `<div class="w-8 h-8 rounded-full cursor-pointer border-2 border-white shadow" style="background-color: ${color};" data-color="${color}"></div>`).join('');
            colorGrid.addEventListener('click', (e) => {
                if (e.target.dataset.color && currentTargetForColor) {
                    const color = e.target.dataset.color;
                    const applyColor = (obj) => {
                        if (obj.stroke && (obj.fill === '' || obj.fill === null)) { obj.set('stroke', color); }
                        else if (obj.fill) { obj.set('fill', color); }
                    };
                    
                    if (currentTargetForColor.isType('group')) {
                        currentTargetForColor.forEachObject(obj => applyColor(obj));
                    } else {
                        applyColor(currentTargetForColor);
                    }
                    canvas.renderAll();
                    colorPaletteContextMenu.classList.add('hidden');
                }
            });
            
            window.addEventListener('mousedown', (e) => {
                if (!colorPaletteContextMenu.classList.contains('hidden') && !colorPaletteContextMenu.contains(e.target)) {
                    colorPaletteContextMenu.classList.add('hidden');
                }
            });

            // --- 그룹 버튼 상태 관리 ---
            const updateGroupButtonsState = () => {
                const activeObject = canvas.getActiveObject();
                if (!activeObject) {
                    toolBtns.group.classList.add('hidden');
                    toolBtns.ungroup.classList.add('hidden');
                    return;
                }
                
                const isMultiSelection = activeObject.type === 'activeSelection';
                const isGroup = activeObject.isType('group') && !activeObject.isType('activeSelection');

                toolBtns.group.classList.toggle('hidden', !isMultiSelection);
                toolBtns.ungroup.classList.toggle('hidden', !isGroup);
            };

            // --- 확인 모달 로직 ---
            const showConfirmModal = (title, message, callback) => {
                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                confirmCallback = callback;
                confirmModal.classList.remove('hidden');
            };

            confirmOkBtn.addEventListener('click', () => {
                if (confirmCallback) confirmCallback();
                confirmModal.classList.add('hidden');
                confirmCallback = null;
            });

            confirmCancelBtn.addEventListener('click', () => {
                confirmModal.classList.add('hidden');
                confirmCallback = null;
            });
            
            // --- 그리기 로직 ---
            const stopDrawing = () => {
                canvas.isDrawingMode = false;
                toolBtns.drawCurve.classList.remove('bg-blue-200');
                toolBtns.drawLine.classList.remove('bg-blue-200');
                toolBtns.stopDrawing.classList.add('hidden');
                canvas.off('path:created');
            };

            toolBtns.stopDrawing.addEventListener('click', stopDrawing);

            toolBtns.drawLine.addEventListener('click', () => {
                stopDrawing();
                canvas.isDrawingMode = true;
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = 8;
                canvas.freeDrawingBrush.color = '#555555';
                canvas.freeDrawingBrush.decimate = 8;
                toolBtns.drawLine.classList.add('bg-blue-200');
                toolBtns.stopDrawing.classList.remove('hidden');

                canvas.once('path:created', (opt) => {
                    const drawnLine = opt.path;
                    addCustomProperties(drawnLine, '선');
                    canvas.setActiveObject(drawnLine);
                    canvas.renderAll();
                    stopDrawing();
                });
            });

            toolBtns.drawCurve.addEventListener('click', () => {
                stopDrawing();
                canvas.isDrawingMode = true;
                canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = 2;
                canvas.freeDrawingBrush.color = '#888888';
                toolBtns.drawCurve.classList.add('bg-blue-200');
                toolBtns.stopDrawing.classList.remove('hidden');

                canvas.once('path:created', (opt) => {
                    const drawnPath = opt.path;
                    let pathString = drawnPath.path.map(p => p.join(' ')).join(' ') + ' Z';

                    const closedShape = new fabric.Path(pathString, {
                        fill: '#cccccc',
                        stroke: null,
                        originX: 'center', originY: 'center',
                        left: drawnPath.left + drawnPath.width / 2,
                        top: drawnPath.top + drawnPath.height / 2,
                    });

                    canvas.remove(drawnPath);
                    addCustomProperties(closedShape, '도형');
                    canvas.add(closedShape);
                    canvas.setActiveObject(closedShape);
                    canvas.renderAll();
                    stopDrawing();
                });
            });
            
            // --- 관리자 & 삭제 키 로직 ---
            window.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && e.target.tagName !== 'INPUT') {
                     const activeObjects = canvas.getActiveObjects();
                    if (activeObjects.length > 0) {
                        showConfirmModal('삭제 확인', `${activeObjects.length}개의 항목을 삭제하시겠습니까?`, () => {
                            activeObjects.forEach(obj => canvas.remove(obj));
                            canvas.discardActiveObject().renderAll();
                        });
                    }
                }
                
                if (e.ctrlKey && e.altKey && (e.key === 'a' || e.key === 'A')) {
                    e.preventDefault();
                    isAdminMode = !isAdminMode;
                    adminUploadBtn.classList.toggle('hidden', !isAdminMode);
                    adminUploadBtn.classList.toggle('flex', isAdminMode);
                    adminModeText.classList.toggle('hidden', !isAdminMode);
                    
                    const activeTab = document.querySelector('.tab-active');
                    if (activeTab) {
                        const category = activeTab.id.split('-')[1];
                        renderParts(category, partsContainer);
                    }
                }
            });

            adminUploadBtn.addEventListener('click', () => adminSvgUploadInput.click());
            adminSvgUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file || !isAdminMode) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const svgString = event.target.result;
                    const newPart = {
                        type: 'svg',
                        svgString: svgString,
                        options: { fill: '#cccccc' }
                    };
                    partsData.shapes.push(newPart);
                    if (tabs.shapes.classList.contains('tab-active')) {
                        renderParts('shapes', partsContainer);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            });


            // --- 캔버스 이벤트 리스너 ---
            canvas.on({
                'object:added': updateAllLayerPanels, 
                'object:removed': updateAllLayerPanels, 
                'selection:created': () => {
                    updateAllLayerPanels();
                    updateGroupButtonsState();
                    saveSelectedBtn.disabled = false;
                }, 
                'selection:updated': () => {
                    updateAllLayerPanels();
                    updateGroupButtonsState();
                    saveSelectedBtn.disabled = false;
                }, 
                'selection:cleared': () => {
                    updateAllLayerPanels();
                    updateGroupButtonsState();
                    saveSelectedBtn.disabled = true;
                },
            });

            // --- 그룹/그룹해제 버튼 리스너 ---
            toolBtns.group.addEventListener('click', () => {
                const activeSelection = canvas.getActiveObject();
                if (!activeSelection || activeSelection.type !== 'activeSelection') return;
                
                const group = activeSelection.toGroup();
                addCustomProperties(group, '그룹');
                canvas.setActiveObject(group);
                canvas.renderAll();
            });

            toolBtns.ungroup.addEventListener('click', () => {
                const activeGroup = canvas.getActiveObject();
                if (!activeGroup || !activeGroup.isType('group')) return;
                
                const items = activeGroup.getObjects();
                activeGroup._restoreObjectsState();
                canvas.remove(activeGroup);
                for (let i = 0; i < items.length; i++) {
                    canvas.add(items[i]);
                }
                canvas.discardActiveObject();
                const sel = new fabric.ActiveSelection(items, { canvas: canvas });
                canvas.setActiveObject(sel);
                canvas.renderAll();
            });

            // --- 모바일 레이어 모달 로직 ---
            toolBtns.panelMobile.addEventListener('click', () => {
                 updateLayerList(mobilePanelContent);
                mobilePanelModal.classList.remove('hidden');
                setTimeout(() => mobilePanelSheet.classList.remove('translate-y-full'), 10);
                switchMobileTab('shapes');
            });
            const closeMobilePanel = () => {
                mobilePanelSheet.classList.add('translate-y-full');
                setTimeout(() => mobilePanelModal.classList.add('hidden'), 300);
            };
            closePanelModalBtn.addEventListener('click', closeMobilePanel);
            mobilePanelModal.addEventListener('click', (e) => { if (e.target === mobilePanelModal) closeMobilePanel(); });
            
            // --- 나머지 모든 기능들 (저장, 파일 업로드 등) ---
            uploadBtn.addEventListener('click', () => svgUploadInput.click());
            svgUploadInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const svgString = event.target.result;
                    fabric.loadSVGFromString(svgString, (objects, options) => {
                        objects.forEach(obj => {
                            if (obj.isType('path')) { obj.set('fill', '#cccccc'); }
                        });

                        const obj = fabric.util.groupSVGElements(objects, options);
                        obj.set({ left: canvas.width / 2, top: canvas.height / 2, originX: 'center', originY: 'center'}).scaleToWidth(100);
                        
                        addCustomProperties(obj, 'SVG');
                        canvas.add(obj).setActiveObject(obj).renderAll();
                    });
                };
                reader.readAsText(file);
                e.target.value = '';
            });

            // 선택 저장
            saveSelectedBtn.addEventListener('click', () => {
                const selection = canvas.getActiveObject();
                if (!selection) return;

                const bounds = selection.getBoundingRect();
                const dataUrl = canvas.toDataURL({
                    left: bounds.left, top: bounds.top, width: bounds.width, height: bounds.height, format: 'png',
                });
                
                previewImage.src = dataUrl;
                centerPoint.style.left = '50%';
                centerPoint.style.top = '50%';
                savePreviewModal.classList.remove('hidden');
            });
            
            closePreviewBtn.addEventListener('click', () => savePreviewModal.classList.add('hidden'));
            savePreviewModal.addEventListener('click', (e) => {
                if(e.target === savePreviewModal) savePreviewModal.classList.add('hidden');
            });

            let isDraggingCenter = false;
            centerPoint.addEventListener('mousedown', () => isDraggingCenter = true);
            window.addEventListener('mouseup', () => isDraggingCenter = false);
            window.addEventListener('mousemove', (e) => {
                if (isDraggingCenter) {
                    const rect = previewContainer.getBoundingClientRect();
                    let x = e.clientX - rect.left;
                    let y = e.clientY - rect.top;
                    x = Math.max(0, Math.min(x, rect.width));
                    y = Math.max(0, Math.min(y, rect.height));
                    centerPoint.style.left = `${(x / rect.width) * 100}%`;
                    centerPoint.style.top = `${(y / rect.height) * 100}%`;
                }
            });
            
            savePngBtn.addEventListener('click', () => {
                const selection = canvas.getActiveObject();
                if (!selection) return;

                const bounds = selection.getBoundingRect();
                const centerPercX = parseFloat(centerPoint.style.left) / 100;
                const centerPercY = parseFloat(centerPoint.style.top) / 100;
                
                const userCenterX = bounds.width * centerPercX;
                const userCenterY = bounds.height * centerPercY;

                const finalWidth = 2 * Math.max(userCenterX, bounds.width - userCenterX);
                const finalHeight = 2 * Math.max(userCenterY, bounds.height - userCenterY);

                const dataUrl = canvas.toDataURL({
                    left: bounds.left, top: bounds.top, width: bounds.width, height: bounds.height, format: 'png',
                });
                
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = finalWidth;
                    tempCanvas.height = finalHeight;
                    const ctx = tempCanvas.getContext('2d');
                    
                    const drawX = finalWidth / 2 - userCenterX;
                    const drawY = finalHeight / 2 - userCenterY;

                    ctx.drawImage(img, drawX, drawY);
                    
                    const finalDataUrl = tempCanvas.toDataURL({ format: 'png' });
                    const filename = (filenameInput.value || 'my-character') + '.png';
                    
                    const triggerDownload = (url, name) => {
                        const a = document.createElement('a');
                        a.href = url; a.download = name;
                        document.body.appendChild(a); a.click(); document.body.removeChild(a);
                    };

                    triggerDownload(finalDataUrl, filename);
                    savePreviewModal.classList.add('hidden');
                };
                img.src = dataUrl;
            });

            saveSvgBtn.addEventListener('click', () => {
                const selection = canvas.getActiveObject();
                if (!selection) return;

                const bounds = selection.getBoundingRect();
                const centerPercX = parseFloat(centerPoint.style.left) / 100;
                const centerPercY = parseFloat(centerPoint.style.top) / 100;
                
                const userCenterX = bounds.width * centerPercX;
                const userCenterY = bounds.height * centerPercY;

                const finalWidth = 2 * Math.max(userCenterX, bounds.width - userCenterX);
                const finalHeight = 2 * Math.max(userCenterY, bounds.height - userCenterY);

                const drawX = finalWidth / 2 - userCenterX;
                const drawY = finalHeight / 2 - userCenterY;

                selection.clone((cloned) => {
                    const tempCanvas = new fabric.StaticCanvas(null, {
                        width: finalWidth,
                        height: finalHeight,
                    });

                    cloned.set({ left: drawX, top: drawY });
                    tempCanvas.add(cloned);
                    const finalSVG = tempCanvas.toSVG();
                    
                    const blob = new Blob([finalSVG], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    
                    const filename = (filenameInput.value || 'my-character') + '.svg';
                    
                    const triggerDownload = (url, name) => {
                        const a = document.createElement('a');
                        a.href = url; a.download = name;
                        document.body.appendChild(a); a.click(); document.body.removeChild(a);
                    };

                    triggerDownload(url, filename);
                    
                    URL.revokeObjectURL(url);
                    savePreviewModal.classList.add('hidden');
                });
            });
        });
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 로비</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Confetti library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .btn { transition: all 0.2s ease; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .name-card {
            position: absolute;
            width: 140px;
            user-select: none;
            transition: transform 0.2s ease, top 0.5s ease, left 0.5s ease, background-color 0.5s ease;
            animation: popIn 0.5s ease-in-out;
        }
        .name-card.draggable { cursor: grab; }
        .name-card.dragging {
            cursor: grabbing;
            z-index: 1000 !important;
            transform: scale(1.05);
            transition: none; 
        }
        .dialogue-text.visible { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes popIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
        .mic-btn.listening { animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { transform: scale(1.1); box-shadow: 0 0 10px 20px rgba(239, 68, 68, 0); } }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4 overflow-hidden">
    <div id="app-container" class="w-full h-full max-w-6xl mx-auto">
        
        <!-- Screen 1: Login Screen -->
        <div id="login-screen" class="text-center bg-white rounded-2xl shadow-lg p-8 max-w-md mx-auto">
            <h1 class="text-2xl md:text-3xl font-bold text-gray-800">환영합니다!</h1>
            <p class="text-gray-500 mt-2 mb-6">정보를 입력하고 입장하세요.</p>
            <div class="space-y-4">
                <input type="text" id="name-input" placeholder="이름" class="w-full border rounded-lg px-4 py-3 text-center focus:ring-2 focus:ring-indigo-500 focus:outline-none" maxlength="10" disabled>
                <input type="text" id="nickname-input" placeholder="닉네임" class="w-full border rounded-lg px-4 py-3 text-center focus:ring-2 focus:ring-indigo-500 focus:outline-none" maxlength="10" disabled>
                <input type="url" id="image-url-input" placeholder="이미지 링크 (선택 사항)" class="w-full border rounded-lg px-4 py-3 text-center focus:ring-2 focus:ring-indigo-500 focus:outline-none" disabled>
                <button id="join-btn" class="w-full btn bg-indigo-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-indigo-700" disabled>입장</button>
            </div>
            <p id="login-error" class="text-red-500 mt-4 h-5">인증 정보를 확인하는 중입니다...</p>
        </div>

        <!-- Screen 2: Lobby Screen -->
        <div id="lobby-screen" class="hidden relative w-full h-[80vh] bg-green-500 rounded-2xl shadow-lg overflow-hidden">
            <div id="countdown-overlay" class="hidden absolute inset-0 bg-black/70 flex-col justify-center items-center z-50">
                <p class="text-white text-3xl font-bold">대화방으로 이동합니다!</p>
                <p id="countdown-timer" class="text-white text-8xl font-bold">3</p>
            </div>
            <div class="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-30 pointer-events-none">
                <div class="text-white font-black text-xl md:text-2xl tracking-widest opacity-80 select-none">PLAYGROUND</div>
                <div class="flex items-center gap-4 pointer-events-auto">
                    <div id="teacher-controls" class="hidden flex gap-2">
                        <button id="situation-manager-btn" class="btn bg-purple-400 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-purple-500">상황 관리</button>
                        <button id="arrange-cards-btn" class="btn bg-green-400 text-green-900 font-bold py-2 px-4 rounded-lg shadow-md hover:bg-green-500">카드 정렬</button>
                        <button id="make-pairs-btn" class="btn bg-yellow-400 text-yellow-900 font-bold py-2 px-4 rounded-lg shadow-md hover:bg-yellow-500">랜덤 짝꿍</button>
                        <button id="create-chat-btn" class="btn bg-blue-400 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-blue-500">대화방 생성</button>
                    </div>
                    <div class="flex items-center gap-2 bg-white/80 backdrop-blur-sm p-2 rounded-lg">
                        <span class="text-lg font-bold text-gray-800">온라인:</span>
                        <span id="user-count" class="text-lg font-bold bg-indigo-100 text-indigo-700 rounded-full px-3 py-1">0</span>
                    </div>
                </div>
            </div>
            <svg id="line-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10"></svg>
            <div id="card-area" class="relative w-full h-full z-20"></div>
        </div>
        
        <!-- Screen 3: Chat Room Screen -->
        <div id="chat-room-screen" class="hidden"></div>
        
        <!-- Modal for Situation Management -->
        <div id="situation-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50 p-4"></div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, updateDoc, writeBatch, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        // --- Firebase 설정 ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // --- DOM 요소 ---
        const loginScreen = document.getElementById('login-screen');
        const lobbyScreen = document.getElementById('lobby-screen');
        const chatRoomScreen = document.getElementById('chat-room-screen');
        const nameInput = document.getElementById('name-input');
        const nicknameInput = document.getElementById('nickname-input');
        const imageUrlInput = document.getElementById('image-url-input');
        const joinBtn = document.getElementById('join-btn');
        const loginError = document.getElementById('login-error');
        const cardArea = document.getElementById('card-area');
        const userCount = document.getElementById('user-count');
        const teacherControls = document.getElementById('teacher-controls');
        const situationManagerBtn = document.getElementById('situation-manager-btn');
        const arrangeCardsBtn = document.getElementById('arrange-cards-btn');
        const makePairsBtn = document.getElementById('make-pairs-btn');
        const createChatBtn = document.getElementById('create-chat-btn');
        const lineContainer = document.getElementById('line-container');
        const situationModal = document.getElementById('situation-modal');
        const countdownOverlay = document.getElementById('countdown-overlay');
        const countdownTimer = document.getElementById('countdown-timer');

        // --- 상태 변수 ---
        let userId = null;
        let unsubscribeUsers = null;
        let unsubscribeLobbyState = null;
        let unsubscribeChatRoom = null;
        const cardElements = {};
        let currentPairs = [];
        let allUsers = [];
        let allSituations = [];
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = SpeechRecognition ? new SpeechRecognition() : null;

        // --- 함수 ---
        const showScreen = (screen) => {
            loginScreen.classList.toggle('hidden', screen !== 'login');
            lobbyScreen.classList.toggle('hidden', screen !== 'lobby');
            chatRoomScreen.classList.toggle('hidden', screen !== 'chat');
        };

        const makeDraggable = (card) => {
            card.onmousedown = null; card.ontouchstart = null;
            let startX, startY, startLeft, startTop, partnerCard, partnerStartLeft, partnerStartTop;
            const onMouseDown = (e) => {
                e.preventDefault(); card.classList.add('dragging');
                const rect = card.getBoundingClientRect();
                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                startX = clientX; startY = clientY; startLeft = card.offsetLeft; startTop = card.offsetTop;
                const pairInfo = currentPairs.find(p => p.ids.includes(userId));
                if (pairInfo) {
                    const partnerId = pairInfo.ids.find(id => id !== userId);
                    partnerCard = cardElements[partnerId];
                    if (partnerCard) { partnerStartLeft = partnerCard.offsetLeft; partnerStartTop = partnerCard.offsetTop; }
                } else { partnerCard = null; }
                document.addEventListener('mousemove', onMouseMove); document.addEventListener('touchmove', onMouseMove, { passive: false });
                document.addEventListener('mouseup', onMouseUp); document.addEventListener('touchend', onMouseUp);
            };
            const onMouseMove = (e) => {
                e.preventDefault();
                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                const dx = clientX - startX; const dy = clientY - startY;
                const moveCard = (targetCard, baseLeft, baseTop) => {
                    const containerRect = cardArea.getBoundingClientRect();
                    let newLeft = baseLeft + dx; let newTop = baseTop + dy;
                    const topBoundary = 60;
                    if (newLeft < 0) newLeft = 0; if (newTop < topBoundary) newTop = topBoundary;
                    if (newLeft + targetCard.offsetWidth > containerRect.width) newLeft = containerRect.width - targetCard.offsetWidth;
                    if (newTop + targetCard.offsetHeight > containerRect.height) newTop = containerRect.height - targetCard.offsetHeight;
                    targetCard.style.left = `${newLeft}px`; targetCard.style.top = `${newTop}px`;
                };
                moveCard(card, startLeft, startTop);
                if (partnerCard) { moveCard(partnerCard, partnerStartLeft, partnerStartTop); }
                drawPairLines();
            };
            const onMouseUp = async () => {
                card.classList.remove('dragging');
                document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('touchmove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp); document.removeEventListener('touchend', onMouseUp);
                const batch = writeBatch(db);
                const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', userId);
                batch.update(userRef, { top: card.style.top, left: card.style.left });
                if (partnerCard) {
                    const partnerId = partnerCard.id.replace('card-', '');
                    const partnerRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', partnerId);
                    batch.update(partnerRef, { top: partnerCard.style.top, left: partnerCard.style.left });
                }
                await batch.commit();
            };
            card.addEventListener('mousedown', onMouseDown); card.addEventListener('touchstart', onMouseDown, { passive: false });
        };
        
        const requestMicrophonePermission = async () => {
            if (recognition) {
                try {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log("마이크 권한이 허용되었습니다.");
                } catch (err) {
                    console.error("마이크 권한이 거부되었습니다.", err);
                }
            }
        };

        const handleJoin = async () => {
            const name = nameInput.value.trim(); const nickname = nicknameInput.value.trim();
            let imageUrl = imageUrlInput.value.trim();
            if (!name || !nickname) { loginError.textContent = '이름과 닉네임을 모두 입력해주세요.'; return; }
            if (!userId) { loginError.textContent = '인증 정보가 없습니다. 새로고침 해주세요.'; return; }
            loginError.textContent = ''; joinBtn.disabled = true;
            if (!imageUrl) {
                let hash = 0;
                for (let i = 0; i < userId.length; i++) { hash = userId.charCodeAt(i) + ((hash << 5) - hash); }
                imageUrl = `https://picsum.photos/seed/${Math.abs(hash)}/140`;
            }
            try {
                const userRef = doc(db, 'artifacts', appId, 'public', 'data', 'users', userId);
                await setDoc(userRef, { name, nickname, imageUrl, top: 'center', left: 'center', chatRoomId: null });
                await requestMicrophonePermission();
                showScreen('lobby');
                listenForUsers(); listenForLobbyState();
            } catch (error) {
                console.error("Error joining lobby:", error);
                loginError.textContent = "입장에 실패했습니다. 다시 시도해주세요."; joinBtn.disabled = false;
            }
        };

        const drawPairLines = () => {
            requestAnimationFrame(() => {
                lineContainer.innerHTML = '';
                if (!currentPairs || currentPairs.length === 0) return;
                currentPairs.forEach(pair => {
                    const card1 = cardElements[pair.ids[0]]; const card2 = cardElements[pair.ids[1]];
                    if (card1 && card2) {
                        const rect1 = card1.getBoundingClientRect(); const rect2 = card2.getBoundingClientRect();
                        const containerRect = lineContainer.getBoundingClientRect();
                        const x1 = rect1.left + rect1.width / 2 - containerRect.left; const y1 = rect1.top + rect1.height / 2 - containerRect.top;
                        const x2 = rect2.left + rect2.width / 2 - containerRect.left; const y2 = rect2.top + rect2.height / 2 - containerRect.top;
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x1); line.setAttribute('y1', y1); line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                        line.setAttribute('stroke', 'white'); line.setAttribute('stroke-width', '4'); line.setAttribute('stroke-dasharray', '10, 5');
                        lineContainer.appendChild(line);
                    }
                });
            });
        };
        
        const listenForLobbyState = () => {
            const lobbyStateRef = doc(db, 'artifacts', appId, 'public', 'data', 'lobbyState', 'main');
            if(unsubscribeLobbyState) unsubscribeLobbyState();
            unsubscribeLobbyState = onSnapshot(lobbyStateRef, (docSnap) => {
                currentPairs = docSnap.exists() ? (docSnap.data().pairs || []) : [];
                allUsers.forEach(user => updateCard(user));
                drawPairLines();
            });
        };

        const updateCard = (user) => {
            let card = cardElements[user.id];
            if (!card) {
                card = document.createElement('div'); card.id = `card-${user.id}`;
                cardArea.appendChild(card); cardElements[user.id] = card;
            }
            const isMe = user.id === userId;
            card.style.height = 'auto'; card.style.zIndex = isMe ? 99 : 1;
            if (user.top === 'center') {
                const containerRect = cardArea.getBoundingClientRect();
                const newTop = (containerRect.height / 2) - 90; const newLeft = (containerRect.width / 2) - 70;
                card.style.top = `${newTop}px`; card.style.left = `${newLeft}px`;
                updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', user.id), { top: `${newTop}px`, left: `${newLeft}px` });
            } else { card.style.top = user.top || '10px'; card.style.left = user.left || '10px'; }
            const pairInfo = currentPairs.find(p => p.ids.includes(user.id));
            const cardBg = pairInfo ? pairInfo.color : 'bg-white/70';
            card.className = `name-card flex flex-col items-center p-2 rounded-2xl backdrop-blur-sm ${cardBg}`;
            let hash = 0; for (let i = 0; i < user.id.length; i++) { hash = user.id.charCodeAt(i) + ((hash << 5) - hash); }
            const colors = ['#fd7f6f', '#7eb0d5', '#b2e061', '#bd7ebe', '#ffb55a', '#ffee65', '#beb9db', '#fdcce5', '#8bd3c7'];
            const color = colors[Math.abs(hash) % colors.length];
            const nameColorClass = isMe ? 'text-indigo-600' : 'text-gray-800';
            card.innerHTML = `<div class="w-24 h-24 mb-2 flex items-center justify-center pointer-events-none">${user.imageUrl ? `<img src="${user.imageUrl}" class="max-w-full max-h-full object-contain" onerror="this.src='https://placehold.co/96x96/${color.substring(1)}/ffffff?text=${user.name.charAt(0)}';">` : `<div class="w-full h-full flex items-center justify-center rounded-lg" style="background-color: ${color};"><span class="text-5xl font-bold text-white">${user.name.charAt(0)}</span></div>`}</div><div class="text-center pointer-events-none"><p class="font-bold text-base ${nameColorClass} truncate w-32">${user.name}</p><p class="text-xs text-gray-500 truncate w-32">${user.nickname}</p></div>`;
            if (isMe) {
                card.classList.add('draggable'); makeDraggable(card);
                if (user.name === '선생님') { teacherControls.classList.remove('hidden'); }
            }
        };

        const listenForUsers = () => {
            const usersCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'users');
            if (unsubscribeUsers) unsubscribeUsers();
            unsubscribeUsers = onSnapshot(usersCollectionRef, (snapshot) => {
                const usersInSnapshot = new Set(); allUsers = [];
                snapshot.forEach((userDoc) => {
                    const user = { id: userDoc.id, ...userDoc.data() };
                    usersInSnapshot.add(user.id); allUsers.push(user);
                    updateCard(user);
                    if (user.id === userId && user.chatRoomId) {
                        listenToChatRoom(user.chatRoomId);
                    }
                });
                Object.keys(cardElements).forEach(id => {
                    if (!usersInSnapshot.has(id)) { cardElements[id].remove(); delete cardElements[id]; }
                });
                userCount.textContent = usersInSnapshot.size;
                drawPairLines();
            });
        };

        const handleArrangeCards = async () => {
            const batch = writeBatch(db); const containerRect = cardArea.getBoundingClientRect();
            const cardWidth = 140, cardHeight = 180, padding = 20, topBoundary = 60;
            const cardsPerRow = Math.floor(containerRect.width / (cardWidth + padding));
            allUsers.forEach((user, index) => {
                const row = Math.floor(index / cardsPerRow); const col = index % cardsPerRow;
                const newLeft = col * (cardWidth + padding) + padding; const newTop = row * (cardHeight + padding) + topBoundary;
                batch.update(doc(db, 'artifacts', appId, 'public', 'data', 'users', user.id), { top: `${newTop}px`, left: `${newLeft}px` });
            });
            await batch.commit();
        };

        const handleMakePairs = async () => {
            const batch = writeBatch(db); const containerRect = cardArea.getBoundingClientRect();
            const cardWidth = 140, pairSpacing = 40, pairWidth = (cardWidth * 2) + pairSpacing;
            const cardHeight = 180, padding = 30, topBoundary = 60;
            const pairsPerRow = Math.floor(containerRect.width / (pairWidth + padding));
            let students = allUsers.filter(u => u.name !== '선생님');
            for (let i = students.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [students[i], students[j]] = [students[j], students[i]]; }
            const pairs = []; const pairColors = ['bg-rose-200/70', 'bg-sky-200/70', 'bg-lime-200/70', 'bg-fuchsia-200/70', 'bg-amber-200/70', 'bg-violet-200/70'];
            let pairIndex = 0;
            for (let i = 0; i < students.length - 1; i += 2) {
                const color = pairColors[pairIndex % pairColors.length];
                pairs.push({ ids: [students[i].id, students[i+1].id], color: color });
                const row = Math.floor(pairIndex / pairsPerRow); const col = pairIndex % pairsPerRow;
                const top = row * (cardHeight + padding) + topBoundary;
                const leftStart = col * (pairWidth + padding) + padding;
                batch.update(doc(db, 'artifacts', appId, 'public', 'data', 'users', students[i].id), { top: `${top}px`, left: `${leftStart}px` });
                batch.update(doc(db, 'artifacts', appId, 'public', 'data', 'users', students[i+1].id), { top: `${top}px`, left: `${leftStart + cardWidth + pairSpacing}px` });
                pairIndex++;
            }
            if (students.length % 2 !== 0) {
                const oddStudent = students[students.length - 1];
                const top = Math.floor(pairIndex / pairsPerRow) * (cardHeight + padding) + topBoundary;
                const left = (pairIndex % pairsPerRow) * (pairWidth + padding) + padding;
                batch.update(doc(db, 'artifacts', appId, 'public', 'data', 'users', oddStudent.id), { top: `${top}px`, left: `${left}px` });
            }
            await batch.commit();
            await setDoc(doc(db, 'artifacts', appId, 'public', 'data', 'lobbyState', 'main'), { pairs });
        };
        
        const handleCreateChatRooms = async () => {
            await fetchAllSituations();
            if (currentPairs.length === 0) { alert("먼저 '랜덤 짝꿍'을 만들어 주세요."); return; }
            if (allSituations.length === 0) { alert("먼저 '상황 관리'에서 대화 상황을 1개 이상 등록해주세요."); return; }
            
            countdownOverlay.classList.remove('hidden');
            countdownOverlay.classList.add('flex');
            let count = 3;
            countdownTimer.textContent = count;
            const interval = setInterval(async () => {
                count--;
                countdownTimer.textContent = count > 0 ? count : 'GO!';
                if (count < 0) {
                    clearInterval(interval);
                    const batch = writeBatch(db);
                    for (const pair of currentPairs) {
                        const situation = allSituations[Math.floor(Math.random() * allSituations.length)];
                        const chatRoomRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'chatRooms'));
                        batch.set(chatRoomRef, { situationId: situation.id, pairIds: pair.ids, step: 0, roles: {} });
                        batch.update(doc(db, 'artifacts', appId, 'public', 'data', 'users', pair.ids[0]), { chatRoomId: chatRoomRef.id });
                        batch.update(doc(db, 'artifacts', appId, 'public', 'data', 'users', pair.ids[1]), { chatRoomId: chatRoomRef.id });
                    }
                    await batch.commit();
                    countdownOverlay.classList.add('hidden');
                }
            }, 1000);
        };

        const listenToChatRoom = (roomId) => {
            if (unsubscribeChatRoom) unsubscribeChatRoom();
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'chatRooms', roomId);
            unsubscribeChatRoom = onSnapshot(roomRef, (docSnap) => {
                if (docSnap.exists()) {
                    showScreen('chat');
                    renderChatRoom(docSnap.data(), roomId);
                } else {
                    showScreen('lobby');
                }
            });
        };

        const renderChatRoom = async (roomData, roomId) => {
            await fetchAllSituations(); 
            const situation = allSituations.find(s => s.id === roomData.situationId);
            if (!situation) return;

            const myUserData = allUsers.find(u => u.id === userId);
            const myRoleNum = roomData.roles[userId];
            const bothRolesSelected = Object.keys(roomData.roles).length === 2;

            const dialogues = [
                { text: situation.dialogue1, trans: situation.translation1, role: 1 },
                { text: situation.dialogue2, trans: situation.translation2, role: 2 },
                // Add more dialogues if your CSV supports them
            ];

            chatRoomScreen.innerHTML = `
                <div class="w-full h-[80vh] bg-gray-800 rounded-2xl p-6 flex flex-col text-white">
                    <h1 class="text-3xl font-bold text-center mb-4">${situation.title}</h1>
                    
                    <div id="role-selection-area" class="flex justify-around items-center my-6 ${bothRolesSelected ? 'hidden' : ''}">
                        <button id="select-role-1" class="btn text-lg p-4 rounded-lg ${roomData.roles[userId] === 1 ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}" ${Object.values(roomData.roles).includes(1) ? 'disabled' : ''}>${situation.role1}</button>
                        <span class="text-xl font-bold">VS</span>
                        <button id="select-role-2" class="btn text-lg p-4 rounded-lg ${roomData.roles[userId] === 2 ? 'bg-green-600' : 'bg-gray-600 hover:bg-gray-500'}" ${Object.values(roomData.roles).includes(2) ? 'disabled' : ''}>${situation.role2}</button>
                    </div>

                    <div id="dialogue-area" class="flex-grow flex flex-col justify-center items-center ${bothRolesSelected ? '' : 'hidden'}">
                        <div id="dialogue-content" class="text-center"></div>
                        <button id="start-dialogue-btn" class="btn bg-green-500 hover:bg-green-600 mt-8 px-8 py-3 text-xl ${roomData.step > 0 ? 'hidden' : ''}">시작</button>
                    </div>

                    <div id="my-chat-card" class="mt-auto pt-4 border-t border-gray-600"></div>
                </div>
            `;
            
            if (myUserData) {
                const myCard = document.getElementById('my-chat-card');
                const myRoleName = myRoleNum ? (myRoleNum === 1 ? situation.role1 : situation.role2) : '역할 선택 중...';
                myCard.innerHTML = `
                    <div class="flex items-center gap-4">
                        <img src="${myUserData.imageUrl}" class="w-16 h-16 object-contain">
                        <div>
                            <p class="font-bold text-lg">${myUserData.name} (${myUserData.nickname})</p>
                            <p class="text-indigo-300 font-bold">${myRoleName}</p>
                        </div>
                    </div>
                `;
            }

            if (!bothRolesSelected) {
                document.getElementById('select-role-1').onclick = () => handleRoleSelect(roomId, 1);
                document.getElementById('select-role-2').onclick = () => handleRoleSelect(roomId, 2);
            } else {
                const dialogueContent = document.getElementById('dialogue-content');
                if (roomData.step > 0 && roomData.step <= dialogues.length) {
                    const currentStep = roomData.step - 1;
                    const currentDialogue = dialogues[currentStep];
                    const isMyTurn = myRoleNum === currentDialogue.role;
                    
                    dialogueContent.innerHTML = `
                        <p class="text-3xl font-bold mb-2">${currentDialogue.text}</p>
                        <p class="text-lg text-gray-300 mb-6">${currentDialogue.trans}</p>
                        <div class="flex items-center justify-center gap-4">
                            <button id="mic-btn" class="mic-btn btn rounded-full p-4 ${isMyTurn ? 'bg-red-600 hover:bg-red-700' : 'bg-gray-500'}" ${!isMyTurn ? 'disabled' : ''}>
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line></svg>
                            </button>
                        </div>
                        <p id="speech-result" class="mt-4 h-6 text-xl"></p>
                    `;
                    if (isMyTurn) {
                        document.getElementById('mic-btn').onclick = () => handleSpeechRecognition(roomId, roomData.step, currentDialogue.text);
                    }
                } else if (roomData.step > dialogues.length) {
                     dialogueContent.innerHTML = `<p class="text-3xl font-bold">모든 대화가 종료되었습니다!</p>`;
                }
                document.getElementById('start-dialogue-btn').onclick = () => updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chatRooms', roomId), { step: 1 });
            }
        };

        const handleRoleSelect = async (roomId, roleNum) => {
            const roomRef = doc(db, 'artifacts', appId, 'public', 'data', 'chatRooms', roomId);
            await updateDoc(roomRef, { [`roles.${userId}`]: roleNum });
        };
        
        const handleSpeechRecognition = (roomId, currentStep, textToMatch) => {
            if (!recognition) { alert("음성 인식이 지원되지 않는 브라우저입니다."); return; }
            const micBtn = document.getElementById('mic-btn');
            const speechResult = document.getElementById('speech-result');
            
            micBtn.classList.add('listening');
            speechResult.textContent = '듣는 중...';
            
            recognition.lang = 'en-US';
            recognition.start();

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                speechResult.textContent = `인식된 내용: ${transcript}`;
                
                const cleanTranscript = transcript.trim().toLowerCase().replace(/[.,!?]/g, '');
                const cleanTextToMatch = textToMatch.trim().toLowerCase().replace(/[.,!?]/g, '');

                if (cleanTranscript === cleanTextToMatch) {
                    speechResult.textContent = '정확합니다!';
                    speechResult.style.color = 'lightgreen';
                    confetti({ particleCount: 150, spread: 90, origin: { y: 0.6 } });
                    setTimeout(() => {
                         updateDoc(doc(db, 'artifacts', appId, 'public', 'data', 'chatRooms', roomId), { step: currentStep + 1 });
                    }, 1500);
                } else {
                    speechResult.textContent = '다시 시도해보세요!';
                    speechResult.style.color = 'lightcoral';
                }
            };
            recognition.onend = () => micBtn.classList.remove('listening');
            recognition.onerror = (event) => {
                speechResult.textContent = `오류: ${event.error}`;
                micBtn.classList.remove('listening');
            };
        };

        const handleLeave = async () => {
            if (userId) {
                try { await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'users', userId)); } 
                catch (error) { console.error("Error deleting user document:", error); }
            }
        };
        
        const fetchAllSituations = async () => {
            const situationsCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'situations');
            const snapshot = await getDocs(situationsCollectionRef);
            allSituations = snapshot.docs.map(d => ({id: d.id, ...d.data()}));
        };

        const openSituationManager = async () => {
            await fetchAllSituations();
            renderSituationModal();
            situationModal.classList.remove('hidden');
        };
        
        const renderSituationModal = () => {
            let situationListHtml = allSituations.map(s => `<div class="flex items-center justify-between p-2 border-b"><span class="font-medium">${s.title}</span><button data-id="${s.id}" class="delete-situation-btn text-red-500 hover:text-red-700">삭제</button></div>`).join('');
            situationModal.innerHTML = `<div class="bg-white p-6 rounded-lg w-full max-w-3xl h-[80vh] flex flex-col"><h2 class="text-2xl font-bold mb-4">상황 관리</h2><div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg text-sm"><p class="font-bold mb-1">CSV 파일 업로드 가이드</p><p>CSV 파일의 첫 줄(헤더)은 반드시 <strong>title,role1,role2,dialogue1,translation1,dialogue2,translation2</strong> 순서로 작성해주세요.</p><p>그 다음 줄부터 이 순서에 맞춰 대화 내용을 입력합니다.</p></div><input type="file" id="csv-upload" accept=".csv" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100 mb-4"/><div class="flex-grow overflow-y-auto border rounded-lg p-2">${situationListHtml || '<p class="text-center text-gray-500">등록된 상황이 없습니다.</p>'}</div><button id="close-modal-btn" class="btn bg-gray-500 text-white mt-4">닫기</button></div>`;
            document.getElementById('close-modal-btn').onclick = () => situationModal.classList.add('hidden');
            document.getElementById('csv-upload').onchange = handleCsvUpload;
            document.querySelectorAll('.delete-situation-btn').forEach(btn => btn.onclick = (e) => handleDeleteSituation(e.target.dataset.id));
        };

        const handleCsvUpload = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = async (e) => {
                const text = e.target.result;
                const rows = text.split('\n').filter(row => row.trim() !== '');
                const header = rows.shift().trim().split(',');
                const requiredHeaders = ['title', 'role1', 'role2', 'dialogue1', 'translation1', 'dialogue2', 'translation2'];
                if (JSON.stringify(header) !== JSON.stringify(requiredHeaders)) {
                    alert('CSV 헤더가 올바르지 않습니다. \n필요한 헤더: ' + requiredHeaders.join(','));
                    return;
                }
                const batch = writeBatch(db);
                rows.forEach(row => {
                    const values = row.split(',');
                    const situationData = { title: values[0], role1: values[1], role2: values[2], dialogue1: values[3], translation1: values[4], dialogue2: values[5], translation2: values[6] };
                    const situationRef = doc(collection(db, 'artifacts', appId, 'public', 'data', 'situations'));
                    batch.set(situationRef, situationData);
                });
                await batch.commit();
                alert(`${rows.length}개의 상황이 등록되었습니다.`);
                openSituationManager();
            };
            reader.readAsText(file);
        };

        const handleDeleteSituation = async (id) => {
            if (confirm("정말로 이 상황을 삭제하시겠습니까?")) {
                await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'situations', id));
                openSituationManager();
            }
        };

        // --- 이벤트 리스너 ---
        joinBtn.addEventListener('click', handleJoin);
        arrangeCardsBtn.addEventListener('click', handleArrangeCards);
        makePairsBtn.addEventListener('click', handleMakePairs);
        createChatBtn.addEventListener('click', handleCreateChatRooms);
        situationManagerBtn.addEventListener('click', openSituationManager);
        window.addEventListener('beforeunload', handleLeave);

        // --- 앱 초기화 ---
        async function initialize() {
            showScreen('login');
            try {
                const customToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                let userCredential;
                if (customToken) {
                    userCredential = await signInWithCustomToken(auth, customToken);
                } else {
                    userCredential = await signInAnonymously(auth);
                }
                userId = userCredential.user.uid;
                
                nameInput.disabled = false; nicknameInput.disabled = false;
                imageUrlInput.disabled = false; joinBtn.disabled = false;
                loginError.textContent = '';
            } catch (error) {
                console.error("Authentication failed:", error);
                loginError.textContent = "인증에 실패했습니다. 페이지를 새로고침 해주세요.";
            }
        }
        
        initialize();
    </script>
</body>
</html>
